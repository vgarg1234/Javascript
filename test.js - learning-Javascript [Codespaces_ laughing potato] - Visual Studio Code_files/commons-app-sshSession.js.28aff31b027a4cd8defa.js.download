"use strict";(self.webpackChunkcodespaces_web_client=self.webpackChunkcodespaces_web_client||[]).push([[175],{25802:(e,s,n)=>{Object.defineProperty(s,"__esModule",{value:!0}),s.SshSession=void 0;const t=n(70158),i=n(30816),o=n(83730),r=n(91714),a=n(45890),c=n(22511),h=n(85523),l=n(948),d=n(28499),u=n(52826),g=n(40770),v=n(4432),p=n(56485),f=n(36149),S=n(23853),w=n(81978),m=n(74330),E=n(28507),y=n(60784),M=n(69727),q=n(36186),R=n(58603),C=n(77316),x=n(62777),T=n(86478),I=n(85670);class k{get algorithms(){return this.protocol?this.protocol.algorithms:null}get principal(){return this.principalValue}set principal(e){this.principalValue=e}constructor(e,s){if(this.config=e,this.remoteVersion=null,this.activatedServices=new Map,this.connectionService=null,this.requestHandlers=new I.Queue,this.blockedMessages=[],this.blockedMessagesSemaphore=new x.Semaphore(1),this.connected=!1,this.disposed=!1,this.metrics=new m.SessionMetrics,this.reconnecting=!1,this.sessionId=null,this.principalValue=null,this.authenticatingEmitter=new o.Emitter,this.onAuthenticating=this.authenticatingEmitter.event,this.closedEmitter=new o.Emitter,this.onClosed=this.closedEmitter.event,this.disconnectedEmitter=new o.Emitter,this.onDisconnected=this.disconnectedEmitter.event,this.serviceActivatedEmitter=new o.Emitter,this.onServiceActivated=this.serviceActivatedEmitter.event,this.channelOpeningEmitter=new o.Emitter,this.onChannelOpening=this.channelOpeningEmitter.event,this.requestEmitter=new o.Emitter,this.onRequest=this.requestEmitter.event,this.trace=(e,s,n,t)=>{},this.isClientSession=s,!e)throw new TypeError("Session configuration is required.");if(e.keyExchangeAlgorithms.find((e=>!!e)))this.kexService=new l.KeyExchangeService(this);else{if(e.encryptionAlgorithms.length>0&&e.encryptionAlgorithms.indexOf(null)<0)throw new Error("Encryption requires a key-exchange algorithm to be configured.");if(e.hmacAlgorithms.length>0&&e.hmacAlgorithms.indexOf(null)<0)throw new Error("HMAC requires a key-exchange algorithm to be configured.");if(e.publicKeyAlgorithms.length>0&&e.publicKeyAlgorithms.indexOf(null)<0)throw new Error("Host authentication requires a key-exchange algorithm to be configured.");this.kexService=null,this.activateService(u.ConnectionService)}e.onConfigurationChanged((()=>{const s=this.protocol;s&&(s.traceChannelData=e.traceChannelData)}))}get isConnected(){return this.connected}get isClosed(){return this.disposed}get services(){return[...this.activatedServices.values()]}get channels(){var e,s;return null!==(s=null===(e=this.connectionService)||void 0===e?void 0:e.channels)&&void 0!==s?s:[]}get protocolExtensions(){var e;return(null===(e=this.protocol)||void 0===e?void 0:e.extensions)||null}getService(e){const s=this.activatedServices.get(e);return s||null}activateService(e){let s;if("function"==typeof e)s=e;else{const n=e;if(s=(0,d.findService)(this.config.services,(e=>e.serviceRequest===n)),!s)return null}let n=this.activatedServices.get(s);if(!n){if(!this.config.services.has(s))throw new Error(`Service type not configured: ${s.name}`);n=new s(this,this.config.services.get(s)),s===u.ConnectionService&&(this.connectionService=n),this.activatedServices.set(s,n),this.serviceActivatedEmitter.fire(n)}return n}async connect(e,s){if(!e)throw new TypeError("A session stream is required.");if(this.disposed)throw new C.ObjectDisposedError(this);this.connectPromise||(this.connectPromise=this.doConnect(e,s)),await this.connectPromise}async doConnect(e,s){this.trace(t.TraceLevel.Info,t.SshTraceEventIds.sessionConnecting,`${this} ${this.reconnecting?"re":""}connecting...`),this.protocol=new h.SshProtocol(e,this.config,this.metrics,this.trace),this.protocol.kexService=this.kexService,await this.exchangeVersions(s),this.kexService?await this.encrypt(s):(await this.sendMessage(p.KeyExchangeInitMessage.none,s),await(0,R.withCancellation)(this.versionExchangePromise,s),this.connected=!0),this.processMessages().catch((e=>{this.trace(t.TraceLevel.Error,t.SshTraceEventIds.unknownError,`Unhandled error processing messages: ${e.message}`,e)}))}async exchangeVersions(e){const s=this.protocol.writeProtocolVersion(k.localVersion.toString(),e),n=this.protocol.readProtocolVersion(e);this.versionExchangePromise=n.then((async e=>{let s;this.trace(t.TraceLevel.Info,t.SshTraceEventIds.protocolVersion,`Local version: ${k.localVersion}, remote version: ${e}`);const n=c.SshVersionInfo.tryParse(e);if(n){if(this.remoteVersion=n,"2.0"===n.protocolVersion)return;s=`Remote SSH version ${this.remoteVersion} is not supported. This library only supports SSH v2.0.`}else s=`Could not parse remote SSH version ${e}`;await this.close(w.SshDisconnectReason.protocolVersionNotSupported,s,new Error(s))})),await s}async encrypt(e){var s,n;const i=this.protocol;if(!i)throw new C.ObjectDisposedError(this);await i.considerReExchange(!0,e),await(0,R.withCancellation)(this.versionExchangePromise,e),this.connected=!0;let o=null;for(;!(this.isClosed||(null===(s=this.protocol)||void 0===s?void 0:s.algorithms)||o instanceof w.DisconnectMessage)&&(o=await i.receiveMessage(e),o);)await this.handleMessage(o,e);if(!(null===(n=this.protocol)||void 0===n?void 0:n.algorithms))throw new C.SshConnectionError("Session closed while encrypting.",w.SshDisconnectReason.connectionLost);this.protocol.algorithms.cipher&&this.trace(t.TraceLevel.Info,t.SshTraceEventIds.sessionEncrypted,`${this} encrypted.`)}async processMessages(){var e;for(this.connected=!0;!this.disposed;){const s=this.protocol;if(!s)break;let n=null;try{n=await s.receiveMessage()}catch(s){if(!(s instanceof Error))throw s;let n=w.SshDisconnectReason.protocolError;s instanceof C.SshConnectionError?n=null!==(e=s.reason)&&void 0!==e?e:n:this.trace(t.TraceLevel.Error,t.SshTraceEventIds.receiveMessageFailed,`Error receiving message: ${s.message}`,s),await this.close(n,s.message,s)}if(!n){await this.close(w.SshDisconnectReason.connectionLost,"Connection lost.");break}try{await this.handleMessage(n)}catch(e){if(!(e instanceof Error))throw e;this.trace(t.TraceLevel.Error,t.SshTraceEventIds.handleMessageFailed,`Error handling ${n}: ${e.message}`,e),await this.close(w.SshDisconnectReason.protocolError,e.message,e)}}this.connected=!1}get canAcceptRequests(){var e;return!(this.kexService&&(!(null===(e=this.protocol)||void 0===e?void 0:e.algorithms)||this.protocol.algorithms.cipher&&!this.principal))}async sendMessage(e,s){var n,i;if(!e)throw new TypeError("Message expected.");if(s&&s.isCancellationRequested)throw new R.CancellationError;const o=this.protocol;if(!o||this.disposed)throw new C.ObjectDisposedError(this);if(this.kexService&&this.kexService.exchanging&&e.messageType>4&&(e.messageType<20||e.messageType>49))return void this.blockedMessages.push(e);let a;await this.blockedMessagesSemaphore.wait(s);try{a=await o.sendMessage(e,s),this.blockedMessagesSemaphore.release()}catch(s){if(this.blockedMessagesSemaphore.release(),s instanceof C.SshConnectionError){if(s.reason===w.SshDisconnectReason.connectionLost&&(null===(n=this.protocolExtensions)||void 0===n?void 0:n.has(r.SshProtocolExtensionNames.sessionReconnect)))return}if(!(s instanceof Error))throw s;throw this.trace(t.TraceLevel.Error,t.SshTraceEventIds.sendMessageFailed,`Error sending ${e}: ${s.message}`,s),s}if(!a&&!(null===(i=this.protocolExtensions)||void 0===i?void 0:i.has(r.SshProtocolExtensionNames.sessionReconnect)))throw new C.SshConnectionError("Session disconnected.",w.SshDisconnectReason.connectionLost)}handleMessage(e,s){var n;if(e instanceof f.ConnectionMessage&&this.connectionService)return this.connectionService.handleMessage(e,s);if(e instanceof p.NewKeysMessage)return this.handleNewKeysMessage(e,s);if(e instanceof p.KeyExchangeMessage)return this.handleKeyExchangeMessage(e,s);if(e instanceof S.AuthenticationMessage)return null===(n=this.getService(g.AuthenticationService))||void 0===n?void 0:n.handleMessage(e,s);if(e instanceof w.ServiceRequestMessage)return this.handleServiceRequestMessage(e,s);if(e instanceof w.ServiceAcceptMessage)return this.handleServiceAcceptMessage(e,s);if(e instanceof w.SessionRequestMessage)return this.handleRequestMessage(e,s);if(e instanceof w.SessionRequestSuccessMessage)return this.handleRequestSuccessMessage(e);if(e instanceof w.SessionRequestFailureMessage)return this.handleRequestFailureMessage(e);if(e instanceof w.ExtensionInfoMessage)return this.handleExtensionInfoMessage(e,s);if(e instanceof w.DisconnectMessage)return this.handleDisconnectMessage(e);if(e instanceof w.UnimplementedMessage)return this.handleUnimplementedMessage(e,s);if(e instanceof w.DebugMessage)return this.handleDebugMessage(e);if(!(e instanceof w.IgnoreMessage))throw e instanceof v.SshMessage?new Error(`Unhandled message type: ${e.constructor.name}`):new TypeError("Message argument was "+(e?"invalid type.":"null."))}async handleRequestMessage(e,s){var n;let i=!1,o=null;if("initial-channel-request@microsoft.com"===e.requestType&&this.config.protocolExtensions.includes(r.SshProtocolExtensionNames.openChannelRequest)){const n=e.convertTo(new w.SessionChannelRequestMessage),t=n.senderChannel,o=this.channels.find((e=>e.remoteChannelId===t));o&&n.request&&(n.request.wantReply=!1,i=await o.handleRequest(n.request,s))}else if("enable-session-reconnect@microsoft.com"===e.requestType&&(null===(n=this.config.protocolExtensions)||void 0===n?void 0:n.includes(r.SshProtocolExtensionNames.sessionReconnect)))this.protocol.incomingMessagesHaveReconnectInfo||(this.protocol.incomingMessagesHaveReconnectInfo=!0,this.protocol.incomingMessagesHaveLatencyInfo=this.protocol.extensions.has(r.SshProtocolExtensionNames.sessionLatency),i=!0);else if(this.canAcceptRequests){const n=new M.SshRequestEventArgs(e.requestType||"",e,this.principal,s),t=(0,d.findService)(this.config.services,(s=>s.sessionRequest===e.requestType));if(t){const e=this.activateService(t);await e.onSessionRequest(n,s)}else this.raiseSessionRequest(n);n.responsePromise?(o=await n.responsePromise,i=o instanceof w.SessionRequestSuccessMessage):i=n.isAuthorized||!1}else this.trace(t.TraceLevel.Warning,t.SshTraceEventIds.sessionRequestFailed,"Session request blocked because the session is not yet authenticated."),i=!1;e.wantReply&&(i?o instanceof w.SessionRequestSuccessMessage||(o=new w.SessionRequestSuccessMessage):o instanceof w.SessionRequestFailureMessage||(o=new w.SessionRequestFailureMessage),await this.sendMessage(o,s))}raiseSessionRequest(e){this.requestEmitter.fire(e)}async handleServiceRequestMessage(e,s){}async handleServiceAcceptMessage(e,s){}async handleKeyExchangeMessage(e,s){this.kexService?await this.kexService.handleMessage(e,s):e instanceof p.KeyExchangeInitMessage&&e.allowsNone||await this.close(w.SshDisconnectReason.keyExchangeFailed,"Encryption is disabled.")}async handleNewKeysMessage(e,s){var n;try{await this.blockedMessagesSemaphore.wait(s),await this.protocol.handleNewKeys(s),(null===(n=this.algorithms)||void 0===n?void 0:n.isExtensionInfoRequested)&&await this.sendExtensionInfo(s);try{for(;this.blockedMessages.length>0;){const e=this.blockedMessages.shift();if(!this.protocol)throw new C.ObjectDisposedError(this);await this.protocol.sendMessage(e,s)}}catch(e){if(!(e instanceof Error))throw e;await this.close(w.SshDisconnectReason.protocolError,void 0,e)}}finally{this.blockedMessagesSemaphore.release()}}async handleUnimplementedMessage(e,s){void 0!==e.unimplementedMessageType&&await this.sendMessage(e,s)}handleDebugMessage(e){e.message&&this.trace(e.alwaysDisplay?t.TraceLevel.Info:t.TraceLevel.Verbose,t.SshTraceEventIds.debugMessage,e.message)}async raiseAuthenticatingEvent(e){this.trace(t.TraceLevel.Info,t.SshTraceEventIds.sessionAuthenticating,`${this} Authenticating(${e})`),this.authenticatingEmitter.fire(e);let s=e.authenticationPromise;s||(s=Promise.resolve(null));return await s}async request(e,s){if(!e)throw new TypeError("Request is required.");if(!e.wantReply)return await this.sendMessage(e,s),!0;return await this.requestResponse(e,w.SessionRequestSuccessMessage,w.SessionRequestFailureMessage,s)instanceof w.SessionRequestSuccessMessage}async requestResponse(e,s,n,t){if(!e)throw new TypeError("Request is required.");if(!s)throw new TypeError("Success response type is required.");if(!n)throw new TypeError("Failure response type is required.");e.wantReply=!0;const i=(e,t)=>{var r,a;if(e)o.reject(e);else{if(i.isCancelled)return;if(t instanceof w.SessionRequestFailureMessage){const e=null!==(r=null==t?void 0:t.convertTo(new n,!0))&&void 0!==r?r:null;o.resolve(e)}else if(t instanceof w.SessionRequestSuccessMessage){const e=null!==(a=null==t?void 0:t.convertTo(new s,!0))&&void 0!==a?a:null;o.resolve(e)}else o.reject(new Error("Unknown response message type."))}},o=new E.PromiseCompletionSource;if(t){if(t.isCancellationRequested)throw new R.CancellationError;t.onCancellationRequested((()=>{i.isCancelled=!0,o.reject(new R.CancellationError)}))}return this.requestHandlers.enqueue(i),await this.sendMessage(e,t),await o.promise}handleRequestSuccessMessage(e){this.invokeRequestHandler(e,void 0,void 0)}handleRequestFailureMessage(e){this.invokeRequestHandler(void 0,e,void 0)}invokeRequestHandler(e,s,n){let t;for(;(t=this.requestHandlers.dequeue())&&(t(n,null!=e?e:s),n););}async acceptChannel(e,s){const n="string"==typeof e?e:void 0;s||"object"!=typeof e||(s=e),this.activateService(u.ConnectionService);const t=this.connectionService.acceptChannel(n||a.SshChannel.sessionChannelType,s);return await t}async openChannel(e,s,n){let t;if("string"==typeof e||null===e?(t=new f.ChannelOpenMessage,t.channelType=null!=e?e:a.SshChannel.sessionChannelType):e instanceof f.ChannelOpenMessage?t=e:(t=new f.ChannelOpenMessage,t.channelType=a.SshChannel.sessionChannelType,n=e),s instanceof f.ChannelRequestMessage)return await this.openChannelWithInitialRequest(t,s,n);n||null===s||(n=s),this.activateService(u.ConnectionService);const i=new E.PromiseCompletionSource;return await this.connectionService.openChannel(t,i,n),await i.promise}async openChannelWithInitialRequest(e,s,n){var t;this.activateService(u.ConnectionService);const i=new E.PromiseCompletionSource,o=await this.connectionService.openChannel(e,i,n);if(n){if(n.isCancellationRequested)throw new R.CancellationError;n.onCancellationRequested((()=>i.reject(new R.CancellationError)))}let a,c;const h=this.config.protocolExtensions.includes(r.SshProtocolExtensionNames.openChannelRequest)&&(null===(t=this.protocolExtensions)||void 0===t?void 0:t.has(r.SshProtocolExtensionNames.openChannelRequest));if(!1===h)a=await i.promise,c=await a.request(s,n);else{const e=s.wantReply||void 0===h,t=new w.SessionChannelRequestMessage;t.requestType="initial-channel-request@microsoft.com",t.senderChannel=o,t.request=s,t.wantReply=e;const r=this.request(t,n);a=await i.promise,e?(c=await r,c||void 0!==h||(c=await a.request(s))):c=!0}if(!c)throw await a.close(),new Error("The initial channel request was denied.");return a}async handleChannelOpening(e,s,n=!0){if(n){const n=(0,d.findService)(this.config.services,(s=>s.channelType===e.channel.channelType&&!s.channelRequest));if(n){const t=this.activateService(n);return void await t.onChannelOpening(e,s)}}e.cancellation=null!=s?s:o.CancellationToken.None,this.channelOpeningEmitter.fire(e)}async sendExtensionInfo(e){if(!this.protocol)return;const s=new w.ExtensionInfoMessage;s.extensionInfo={};for(const e of this.config.protocolExtensions)if(e===r.SshProtocolExtensionNames.serverSignatureAlgorithms){const n=Array.from(new Set((0,q.algorithmNames)(this.config.publicKeyAlgorithms))).join(",");s.extensionInfo[e]=n}else s.extensionInfo[e]="";await this.protocol.sendMessage(s,e)}async handleExtensionInfoMessage(e,s){if(!this.protocol)return;this.protocol.extensions=new Map;if(e.extensionInfo){for(const s of this.config.protocolExtensions){const n=e.extensionInfo[s];"string"==typeof n&&this.protocol.extensions.set(s,n)}this.protocol.extensions.has(r.SshProtocolExtensionNames.sessionReconnect)&&await this.enableReconnect(s)}}async close(e,s,n){var i,o,r;if(!this.disposed&&this.connected){if(this.connected=!1,this.trace(t.TraceLevel.Info,t.SshTraceEventIds.sessionClosing,`${this} Close(${w.SshDisconnectReason[e]}, "${s||""}")`),e!==w.SshDisconnectReason.connectionLost)try{const n=new w.DisconnectMessage;n.reasonCode=e,n.description=s||"",await(null===(i=this.protocol)||void 0===i?void 0:i.sendMessage(n))}catch(e){}else if(this.handleDisconnected())return null===(o=this.protocol)||void 0===o||o.dispose(),this.trace(t.TraceLevel.Info,t.SshTraceEventIds.sessionDisconnected,`${this} disconnected.`),void this.disconnectedEmitter.fire();this.disposed=!0,this.closedError=n,(n=null!=n?n:new C.SshConnectionError(s,e))&&(null===(r=this.connectionService)||void 0===r||r.close(n)),this.closedEmitter.fire(new y.SshSessionClosedEventArgs(e,s||"Disconnected.",n)),this.dispose()}}handleDisconnected(){var e,s;return this.connectPromise=void 0,null===(e=this.kexService)||void 0===e||e.abortKeyExchange(),!!(null===(s=this.protocolExtensions)||void 0===s?void 0:s.has(r.SshProtocolExtensionNames.sessionReconnect))}async handleDisconnectMessage(e){var s;const n=e.description||"Received disconnect message.";await this.close(null!==(s=e.reasonCode)&&void 0!==s?s:w.SshDisconnectReason.none,n)}dispose(e){var s,n;const i=null!=e?e:this.closedError instanceof C.SshConnectionError?this.closedError:new C.SshConnectionError(this.constructor.name+" disposed.");this.disposed||(this.trace(t.TraceLevel.Info,t.SshTraceEventIds.sessionClosing,`${this} disposed.`),this.disposed=!0,this.closedEmitter.fire(new y.SshSessionClosedEventArgs(w.SshDisconnectReason.none,i.message,i))),this.invokeRequestHandler(void 0,void 0,i),this.metrics.close(),null===(s=this.connectionService)||void 0===s||s.dispose();for(const e of this.activatedServices.values())e!==this.connectionService&&e.dispose();this.activatedServices.clear(),null===(n=this.protocol)||void 0===n||n.dispose(),this.protocol=void 0}async enableReconnect(e){var s;try{if(await this.blockedMessagesSemaphore.wait(),null===(s=this.kexService)||void 0===s?void 0:s.exchanging)this.trace(t.TraceLevel.Error,t.SshTraceEventIds.sessionReconnectInitFailed,"Failed to initialize session reconnect because a key-exchange was in-progress.");else{const s=new w.SessionRequestMessage("enable-session-reconnect@microsoft.com",!1);await this.protocol.sendMessage(s,e),this.protocol&&(this.protocol.outgoingMessagesHaveReconnectInfo=!0,this.protocol.outgoingMessagesHaveLatencyInfo=this.protocol.extensions.has(r.SshProtocolExtensionNames.sessionLatency))}this.blockedMessagesSemaphore.release()}catch(e){throw this.blockedMessagesSemaphore.release(),e instanceof Error&&await this.close(w.SshDisconnectReason.protocolError,void 0,e),e}}async createReconnectToken(e,s){return await this.algorithms.signer.sign(i.Buffer.concat([e,s]))}async verifyReconnectToken(e,s,n){return await this.algorithms.verifier.verify(i.Buffer.concat([e,s]),n)}pipe(e){return T.PipeExtensions.pipeSession(this,e)}toString(){return this.constructor.name}}s.SshSession=k,k.localVersion=c.SshVersionInfo.getLocalVersion()},7395:(e,s,n)=>{Object.defineProperty(s,"__esModule",{value:!0}),s.SshSession=void 0;const t=n(43776),i=n(30816),o=n(83730),r=n(97183),a=n(34756),c=n(87505),h=n(17585),l=n(43210),d=n(34670),u=n(47165),g=n(76502),v=n(285),p=n(50856),f=n(45757),S=n(90450),w=n(90818),m=n(13965),E=n(93708),y=n(13068),M=n(96002),q=n(91605),R=n(97437),C=n(72917),x=n(24564),T=n(76356);class I{constructor(e,s){if(this.config=e,this.remoteVersion=null,this.activatedServices=new Map,this.connectionService=null,this.requestHandler=null,this.blockedMessages=[],this.blockedMessagesSemaphore=new x.Semaphore(1),this.connected=!1,this.disposed=!1,this.metrics=new m.SessionMetrics,this.reconnecting=!1,this.sessionId=null,this.principalValue=null,this.authenticatingEmitter=new o.Emitter,this.onAuthenticating=this.authenticatingEmitter.event,this.closedEmitter=new o.Emitter,this.onClosed=this.closedEmitter.event,this.disconnectedEmitter=new o.Emitter,this.onDisconnected=this.disconnectedEmitter.event,this.serviceActivatedEmitter=new o.Emitter,this.onServiceActivated=this.serviceActivatedEmitter.event,this.channelOpeningEmitter=new o.Emitter,this.onChannelOpening=this.channelOpeningEmitter.event,this.requestEmitter=new o.Emitter,this.onRequest=this.requestEmitter.event,this.trace=(e,s,n,t)=>{},!e)throw new TypeError("Session configuration is required.");if(e.keyExchangeAlgorithms.find((e=>!!e)))this.kexService=new l.KeyExchangeService(this,null!=s&&s);else{if(e.encryptionAlgorithms.length>0&&e.encryptionAlgorithms.indexOf(null)<0)throw new Error("Encryption requires a key-exchange algorithm to be configured.");if(e.hmacAlgorithms.length>0&&e.hmacAlgorithms.indexOf(null)<0)throw new Error("HMAC requires a key-exchange algorithm to be configured.");if(e.publicKeyAlgorithms.length>0&&e.publicKeyAlgorithms.indexOf(null)<0)throw new Error("Host authentication requires a key-exchange algorithm to be configured.");this.kexService=null}e.onConfigurationChanged((()=>{const s=this.protocol;s&&(s.traceChannelData=e.traceChannelData)}))}get algorithms(){return this.protocol?this.protocol.algorithms:null}get principal(){return this.principalValue}set principal(e){this.principalValue=e}get isConnected(){return this.connected}get isClosed(){return this.disposed}get services(){return[...this.activatedServices.values()]}get channels(){var e,s;return null!==(s=null===(e=this.connectionService)||void 0===e?void 0:e.channels)&&void 0!==s?s:[]}get protocolExtensions(){var e;return(null===(e=this.protocol)||void 0===e?void 0:e.extensions)||null}getService(e){const s=this.activatedServices.get(e);return s||null}activateService(e){let s;if("function"==typeof e)s=e;else{let n=e;if(s=(0,d.findService)(this.config.services,(e=>e.serviceRequest===n)),!s)return null}let n=this.activatedServices.get(s);if(!n){if(!this.config.services.has(s))throw new Error(`Service type not configured: ${s.name}`);n=new s(this,this.config.services.get(s)),s===u.ConnectionService&&(this.connectionService=n),this.activatedServices.set(s,n),this.serviceActivatedEmitter.fire(n)}return n}async connect(e,s){if(!e)throw new TypeError("A session stream is required.");if(this.disposed)throw new C.ObjectDisposedError(this);this.connectPromise||(this.connectPromise=this.doConnect(e,s)),await this.connectPromise}async doConnect(e,s){this.trace(t.TraceLevel.Info,t.SshTraceEventIds.sessionConnecting,`${this} ${this.reconnecting?"re":""}connecting...`),this.protocol=new h.SshProtocol(e,this.config,this.metrics,this.trace),this.protocol.kexService=this.kexService,await this.exchangeVersions(s),this.kexService?await this.encrypt(s):(await(0,R.withCancellation)(this.versionExchangePromise,s),this.connected=!0),this.processMessages().catch((e=>{this.trace(t.TraceLevel.Error,t.SshTraceEventIds.unknownError,`Unhandled error processing messages: ${e.message}`,e)}))}async exchangeVersions(e){const s=this.protocol.writeProtocolVersion(I.localVersion.toString(),e),n=this.protocol.readProtocolVersion(e);this.versionExchangePromise=n.then((async e=>{let s;this.trace(t.TraceLevel.Info,t.SshTraceEventIds.protocolVersion,`Local version: ${I.localVersion}, remote version: ${e}`);const n=c.SshVersionInfo.tryParse(e);if(n){if(this.remoteVersion=n,"2.0"===n.protocolVersion)return;s=`Remote SSH version ${this.remoteVersion} is not supported. This library only supports SSH v2.0.`}else s=`Could not parse remote SSH version ${e}`;await this.close(w.SshDisconnectReason.protocolVersionNotSupported,s,new Error(s))})),await s}async encrypt(e){var s,n;const i=this.protocol;if(!i)throw new C.ObjectDisposedError(this);await i.considerReExchange(!0,e),await(0,R.withCancellation)(this.versionExchangePromise,e),this.connected=!0;let o=null;for(;!(this.isClosed||(null===(s=this.protocol)||void 0===s?void 0:s.algorithms)||o instanceof w.DisconnectMessage)&&(o=await i.receiveMessage(e),o);)await this.handleMessage(o,e);if(!(null===(n=this.protocol)||void 0===n?void 0:n.algorithms))throw new C.SshConnectionError("Session closed while encrypting.",w.SshDisconnectReason.connectionLost);this.protocol.algorithms.cipher&&this.trace(t.TraceLevel.Info,t.SshTraceEventIds.sessionEncrypted,`${this} encrypted.`)}async processMessages(){var e;for(this.connected=!0;!this.disposed;){const s=this.protocol;if(!s)break;let n=null;try{n=await s.receiveMessage()}catch(s){if(!(s instanceof Error))throw s;let n=w.SshDisconnectReason.protocolError;s instanceof C.SshConnectionError?n=null!==(e=s.reason)&&void 0!==e?e:n:this.trace(t.TraceLevel.Error,t.SshTraceEventIds.receiveMessageFailed,`Error receiving message: ${s.message}`,s),await this.close(n,s.message,s)}if(!n){await this.close(w.SshDisconnectReason.connectionLost,"Connection lost.");break}try{await this.handleMessage(n)}catch(e){if(!(e instanceof Error))throw e;this.trace(t.TraceLevel.Error,t.SshTraceEventIds.handleMessageFailed,`Error handling ${n}: ${e.message}`,e),await this.close(w.SshDisconnectReason.protocolError,e.message,e)}}this.connected=!1}get canAcceptRequests(){var e;return!(this.kexService&&(!(null===(e=this.protocol)||void 0===e?void 0:e.algorithms)||this.protocol.algorithms.cipher&&!this.principal))}async sendMessage(e,s){var n,i;if(!e)throw new TypeError("Message expected.");if(s&&s.isCancellationRequested)throw new R.CancellationError;const o=this.protocol;if(!o||this.disposed)throw new C.ObjectDisposedError(this);if(this.kexService&&this.kexService.exchanging&&e.messageType>4&&(e.messageType<20||e.messageType>49))return void this.blockedMessages.push(e);let a;await this.blockedMessagesSemaphore.wait(s);try{a=await o.sendMessage(e,s),this.blockedMessagesSemaphore.release()}catch(s){if(this.blockedMessagesSemaphore.release(),s instanceof C.SshConnectionError){if(s.reason===w.SshDisconnectReason.connectionLost&&(null===(n=this.protocolExtensions)||void 0===n?void 0:n.has(r.SshProtocolExtensionNames.sessionReconnect)))return}if(!(s instanceof Error))throw s;throw this.trace(t.TraceLevel.Error,t.SshTraceEventIds.sendMessageFailed,`Error sending ${e}: ${s.message}`,s),s}if(!a&&!(null===(i=this.protocolExtensions)||void 0===i?void 0:i.has(r.SshProtocolExtensionNames.sessionReconnect)))throw new C.SshConnectionError("Session disconnected.",w.SshDisconnectReason.connectionLost)}handleMessage(e,s){var n;if(e instanceof f.ConnectionMessage&&this.connectionService)return this.connectionService.handleMessage(e,s);if(e instanceof p.NewKeysMessage)return this.handleNewKeysMessage(e,s);if(e instanceof p.KeyExchangeMessage)return this.handleKeyExchangeMessage(e,s);if(e instanceof S.AuthenticationMessage)return null===(n=this.getService(g.AuthenticationService))||void 0===n?void 0:n.handleMessage(e,s);if(e instanceof w.ServiceRequestMessage)return this.handleServiceRequestMessage(e,s);if(e instanceof w.ServiceAcceptMessage)return this.handleServiceAcceptMessage(e,s);if(e instanceof w.SessionRequestMessage)return this.handleRequestMessage(e,s);if(e instanceof w.SessionRequestSuccessMessage)return this.handleRequestSuccessMessage(e);if(e instanceof w.SessionRequestFailureMessage)return this.handleRequestFailureMessage(e);if(e instanceof w.ExtensionInfoMessage)return this.handleExtensionInfoMessage(e,s);if(e instanceof w.DisconnectMessage)return this.handleDisconnectMessage(e);if(e instanceof w.UnimplementedMessage)return this.handleUnimplementedMessage(e,s);if(e instanceof w.DebugMessage)return this.handleDebugMessage(e);throw e instanceof v.SshMessage?new Error(`Unhandled message type: ${e.constructor.name}`):new TypeError("Message argument was "+(e?"invalid type.":"null."))}async handleRequestMessage(e,s){var n;let i=!1,o=null;if("initial-channel-request@microsoft.com"===e.requestType&&this.config.protocolExtensions.includes(r.SshProtocolExtensionNames.openChannelRequest)){const n=e.convertTo(new w.SessionChannelRequestMessage),t=n.senderChannel,o=this.channels.find((e=>e.remoteChannelId===t));o&&n.request&&(n.request.wantReply=!1,i=await o.handleRequest(n.request,s))}else if("enable-session-reconnect@microsoft.com"===e.requestType&&(null===(n=this.config.protocolExtensions)||void 0===n?void 0:n.includes(r.SshProtocolExtensionNames.sessionReconnect)))this.protocol.incomingMessagesHaveReconnectInfo||(this.protocol.incomingMessagesHaveReconnectInfo=!0,this.protocol.incomingMessagesHaveLatencyInfo=this.protocol.extensions.has(r.SshProtocolExtensionNames.sessionLatency),i=!0);else if(this.canAcceptRequests){const n=new M.SshRequestEventArgs(e.requestType||"",e,this.principal,s),t=(0,d.findService)(this.config.services,(s=>s.sessionRequest===e.requestType));if(t){const e=this.activateService(t);await e.onSessionRequest(n,s)}else this.raiseSessionRequest(n);n.responsePromise?(o=await n.responsePromise,i=o instanceof w.SessionRequestSuccessMessage):i=n.isAuthorized||!1}else this.trace(t.TraceLevel.Warning,t.SshTraceEventIds.sessionRequestFailed,"Session request blocked because the session is not yet authenticated."),i=!1;e.wantReply&&(i?o instanceof w.SessionRequestSuccessMessage||(o=new w.SessionRequestSuccessMessage):o instanceof w.SessionRequestFailureMessage||(o=new w.SessionRequestFailureMessage),await this.sendMessage(o,s))}raiseSessionRequest(e){this.requestEmitter.fire(e)}async handleServiceRequestMessage(e,s){}async handleServiceAcceptMessage(e,s){}async handleKeyExchangeMessage(e,s){if(!this.kexService){if(!(e instanceof p.KeyExchangeInitMessage&&this.protocol))return void await this.close(w.SshDisconnectReason.keyExchangeFailed);this.kexService=this.activateService(l.KeyExchangeService),this.protocol.kexService=this.kexService,await this.protocol.considerReExchange(!0,s)}return this.kexService.handleMessage(e,s)}async handleNewKeysMessage(e,s){try{await this.blockedMessagesSemaphore.wait(s),await this.protocol.handleNewKeys(s);try{for(;this.blockedMessages.length>0;){const e=this.blockedMessages.shift();if(!this.protocol)throw new C.ObjectDisposedError(this);await this.protocol.sendMessage(e,s)}}catch(e){if(!(e instanceof Error))throw e;await this.close(w.SshDisconnectReason.protocolError,void 0,e)}}finally{this.blockedMessagesSemaphore.release()}}async handleUnimplementedMessage(e,s){void 0!==e.unimplementedMessageType&&await this.sendMessage(e,s)}handleDebugMessage(e){e.message&&this.trace(e.alwaysDisplay?t.TraceLevel.Info:t.TraceLevel.Verbose,t.SshTraceEventIds.debugMessage,e.message)}async raiseAuthenticatingEvent(e){this.trace(t.TraceLevel.Info,t.SshTraceEventIds.sessionAuthenticating,`${this} Authenticating(${e})`),this.authenticatingEmitter.fire(e);let s=e.authenticationPromise;s||(s=Promise.resolve(null));return await s}async request(e,s){if(!e)throw new TypeError("Request is required.");if(!e.wantReply)return await this.sendMessage(e,s),!0;return await this.requestResponse(e,w.SessionRequestSuccessMessage,w.SessionRequestFailureMessage,s)instanceof w.SessionRequestSuccessMessage}async requestResponse(e,s,n,t){if(!e)throw new TypeError("Request is required.");if(!s)throw new TypeError("Success response type is required.");if(!n)throw new TypeError("Failure response type is required.");if(this.requestHandler)throw new Error("Another request is already pending.");e.wantReply=!0;const i=new E.PromiseCompletionSource;if(t){if(t.isCancellationRequested)throw new R.CancellationError;t.onCancellationRequested((()=>{this.requestHandler=null,i.reject(new R.CancellationError)}))}return this.requestHandler=(e,t)=>{var o,r;if(this.requestHandler=null,e)i.reject(e);else if(t instanceof w.SessionRequestFailureMessage){const e=null!==(o=null==t?void 0:t.convertTo(new n,!0))&&void 0!==o?o:null;i.resolve(e)}else if(t instanceof w.SessionRequestSuccessMessage){const e=null!==(r=null==t?void 0:t.convertTo(new s,!0))&&void 0!==r?r:null;i.resolve(e)}else i.reject(new Error("Unknown response message type."))},await this.sendMessage(e,t),await i.promise}handleRequestSuccessMessage(e){this.requestHandler&&this.requestHandler(void 0,e)}handleRequestFailureMessage(e){this.requestHandler&&this.requestHandler(void 0,e)}async acceptChannel(e,s){const n="string"==typeof e?e:void 0;s||"object"!=typeof e||(s=e),this.activateService(u.ConnectionService);const t=this.connectionService.acceptChannel(n||a.SshChannel.sessionChannelType,s);return await t}async openChannel(e,s,n){let t;if("string"==typeof e||null===e?(t=new f.ChannelOpenMessage,t.channelType=null!=e?e:a.SshChannel.sessionChannelType):e instanceof f.ChannelOpenMessage?t=e:(t=new f.ChannelOpenMessage,t.channelType=a.SshChannel.sessionChannelType,n=e),s instanceof f.ChannelRequestMessage)return await this.openChannelWithInitialRequest(t,s,n);n||null===s||(n=s),this.activateService(u.ConnectionService);const i=new E.PromiseCompletionSource;return await this.connectionService.openChannel(t,i,n),await i.promise}async openChannelWithInitialRequest(e,s,n){var t;this.activateService(u.ConnectionService);const i=new E.PromiseCompletionSource,o=await this.connectionService.openChannel(e,i,n);if(n){if(n.isCancellationRequested)throw new R.CancellationError;n.onCancellationRequested((()=>i.reject(new R.CancellationError)))}let a,c;const h=this.config.protocolExtensions.includes(r.SshProtocolExtensionNames.openChannelRequest)&&(null===(t=this.protocolExtensions)||void 0===t?void 0:t.has(r.SshProtocolExtensionNames.openChannelRequest));if(!1===h)a=await i.promise,c=await a.request(s,n);else{const e=s.wantReply||void 0===h,t=new w.SessionChannelRequestMessage;t.requestType="initial-channel-request@microsoft.com",t.senderChannel=o,t.request=s,t.wantReply=e;const r=this.request(t,n);a=await i.promise,e?(c=await r,c||void 0!==h||(c=await a.request(s))):c=!0}if(!c)throw await a.close(),new Error("The initial channel request was denied.");return a}async handleChannelOpening(e,s,n=!0){if(n){const n=(0,d.findService)(this.config.services,(s=>s.channelType===e.channel.channelType&&!s.channelRequest));if(n){const t=this.activateService(n);return void await t.onChannelOpening(e,s)}}e.cancellation=null!=s?s:o.CancellationToken.None,this.channelOpeningEmitter.fire(e),e.openingPromise&&await e.openingPromise}async sendExtensionInfo(e){const s=new w.ExtensionInfoMessage;s.extensionInfo={};for(let e of this.config.protocolExtensions)if(e===r.SshProtocolExtensionNames.serverSignatureAlgorithms){const n=Array.from(new Set((0,q.algorithmNames)(this.config.publicKeyAlgorithms))).join(",");s.extensionInfo[e]=n}else s.extensionInfo[e]="";await this.sendMessage(s,e)}async handleExtensionInfoMessage(e,s){if(!this.protocol)return;this.protocol.extensions=new Map;if(e.extensionInfo){for(let s of this.config.protocolExtensions){const n=e.extensionInfo[s];"string"==typeof n&&this.protocol.extensions.set(s,n)}this.protocol.extensions.has(r.SshProtocolExtensionNames.sessionReconnect)&&await this.enableReconnect(s)}}async close(e,s,n){var i,o,r;if(!this.disposed&&this.connected){if(this.connected=!1,this.trace(t.TraceLevel.Info,t.SshTraceEventIds.sessionClosing,`${this} Close(${w.SshDisconnectReason[e]}, "${s||""}")`),e!==w.SshDisconnectReason.connectionLost)try{const n=new w.DisconnectMessage;n.reasonCode=e,n.description=s||"",await(null===(i=this.protocol)||void 0===i?void 0:i.sendMessage(n))}catch(e){}else if(this.handleDisconnected())return null===(o=this.protocol)||void 0===o||o.dispose(),this.trace(t.TraceLevel.Info,t.SshTraceEventIds.sessionDisconnected,`${this} disconnected.`),void this.disconnectedEmitter.fire();this.disposed=!0,n&&(null===(r=this.connectionService)||void 0===r||r.close(n)),this.closedEmitter.fire(new y.SshSessionClosedEventArgs(e,s||"Disconnected.",n||null)),this.dispose()}}handleDisconnected(){var e,s;return this.connectPromise=void 0,null===(e=this.kexService)||void 0===e||e.abortKeyExchange(),!!(null===(s=this.protocolExtensions)||void 0===s?void 0:s.has(r.SshProtocolExtensionNames.sessionReconnect))}async handleDisconnectMessage(e){var s;await this.close(null!==(s=e.reasonCode)&&void 0!==s?s:w.SshDisconnectReason.none,e.description)}dispose(){var e,s;this.disposed||(this.trace(t.TraceLevel.Info,t.SshTraceEventIds.sessionClosing,`${this} disposed.`),this.disposed=!0,this.closedEmitter.fire(new y.SshSessionClosedEventArgs(w.SshDisconnectReason.none,"SshSession disposed",null))),this.requestHandler&&this.requestHandler(new C.SshConnectionError("Connection closed.")),this.metrics.close(),null===(e=this.connectionService)||void 0===e||e.dispose();for(let e of this.activatedServices.values())e!==this.connectionService&&e.dispose();this.activatedServices.clear(),null===(s=this.protocol)||void 0===s||s.dispose(),this.protocol=void 0}async enableReconnect(e){var s;try{if(await this.blockedMessagesSemaphore.wait(),null===(s=this.kexService)||void 0===s?void 0:s.exchanging)this.trace(t.TraceLevel.Error,t.SshTraceEventIds.sessionReconnectInitFailed,"Failed to initialize session reconnect because a key-exchange was in-progress.");else{const s=new w.SessionRequestMessage("enable-session-reconnect@microsoft.com",!1);await this.protocol.sendMessage(s,e),this.protocol&&(this.protocol.outgoingMessagesHaveReconnectInfo=!0,this.protocol.outgoingMessagesHaveLatencyInfo=this.protocol.extensions.has(r.SshProtocolExtensionNames.sessionLatency))}this.blockedMessagesSemaphore.release()}catch(e){throw this.blockedMessagesSemaphore.release(),e instanceof Error&&await this.close(w.SshDisconnectReason.protocolError,void 0,e),e}}async createReconnectToken(e,s){return await this.algorithms.signer.sign(i.Buffer.concat([e,s]))}async verifyReconnectToken(e,s,n){return await this.algorithms.verifier.verify(i.Buffer.concat([e,s]),n)}pipe(e){return T.PipeExtensions.pipeSession(this,e)}toString(){return this.constructor.name}}s.SshSession=I,I.localVersion=c.SshVersionInfo.getLocalVersion()}}]);