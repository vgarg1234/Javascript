"use strict";(self.webpackChunkcodespaces_web_client=self.webpackChunkcodespaces_web_client||[]).push([[650],{4762:(e,t,n)=>{var s=n(30816).Buffer;Object.defineProperty(t,"__esModule",{value:!0}),t.SshClientSession=void 0;const i=n(25802),c=n(81978),o=n(35619),r=n(28507),a=n(58603),h=n(91714),l=n(40770),u=n(52826),d=n(77316),v=n(70158);class S extends i.SshSession{constructor(e){super(e,!0),this.serviceRequests=new Map,this.clientAuthCompletion=null}async authenticate(e,t){if(!await this.authenticateServer(t))return!1;return!!await this.authenticateClient(e,t)}async authenticateServer(e){if(!this.kexService||!this.kexService.hostKey)throw new Error("Encrypt the session before authenticating.");try{this.principal=await this.raiseAuthenticatingEvent(new o.SshAuthenticatingEventArgs(o.SshAuthenticationType.serverPublicKey,{publicKey:this.kexService.hostKey},e))}catch(e){if(!(e instanceof Error))throw e;throw this.trace(v.TraceLevel.Error,v.SshTraceEventIds.authenticationError,`Error while authenticating server: ${e.message}`,e),e}return this.principal?(this.trace(v.TraceLevel.Info,v.SshTraceEventIds.sessionAuthenticated,`${this} server authenticated.`),!0):(await this.close(c.SshDisconnectReason.hostKeyNotVerifiable,"Server authentication failed."),this.trace(v.TraceLevel.Warning,v.SshTraceEventIds.serverAuthenticationFailed,`${this} server authentication failed.`),!1)}authenticateClient(e,t,n){if(!e)throw new TypeError("A credentials object is required.");return"function"==typeof t?this.authenticateClientWithCompletion(e,t,n):new Promise(((n,s)=>this.authenticateClientWithCompletion(e,((e,t)=>{e?s(e):n(t)}),t)))}async authenticateClientWithCompletion(e,t,n){if(this.clientAuthCompletion=new r.PromiseCompletionSource,this.clientAuthCompletion.promise.then((e=>t(void 0,e)),(e=>t(e))),n){if(n.isCancellationRequested)throw new a.CancellationError;n.onCancellationRequested((e=>{this.clientAuthCompletion&&this.clientAuthCompletion.reject(new a.CancellationError)}))}let s=this.getService(l.AuthenticationService);if(!s){const e=new c.ServiceRequestMessage;e.serviceName=l.AuthenticationService.serviceName,await this.sendMessage(e,n),s=this.activateService(l.AuthenticationService)}await s.authenticateClient(e,n)}onAuthenticationComplete(e){e?this.trace(v.TraceLevel.Info,v.SshTraceEventIds.sessionAuthenticated,`${this} client authenticated.`):this.trace(v.TraceLevel.Warning,v.SshTraceEventIds.clientAuthenticationFailed,`${this} client authentication failed.`),this.clientAuthCompletion&&(this.clientAuthCompletion.resolve(e),this.clientAuthCompletion=null)}async requestService(e,t){let n=!1,s=this.serviceRequests.get(e);if(s||(s=new r.PromiseCompletionSource,this.serviceRequests.set(e,s),n=!0),n){const n=new c.ServiceRequestMessage;n.serviceName=e,await this.sendMessage(n,t)}await s.promise}async handleServiceAcceptMessage(e,t){const n=this.serviceRequests.get(e.serviceName);null==n||n.resolve(!0)}async openChannel(e,t,n){if(!this.connectionService){const e=new c.ServiceRequestMessage;e.serviceName=u.ConnectionService.serviceName,await this.sendMessage(e,n)}return await super.openChannel(e,t,n)}handleDisconnected(){return this.reconnecting?(this.reconnecting=!1,!1):super.handleDisconnected()}async reconnect(e,t){if(this.trace(v.TraceLevel.Verbose,v.SshTraceEventIds.clientSessionReconnecting,"Attempting to reconnect..."),this.isClosed)throw new d.ObjectDisposedError(this);if(this.isConnected)throw new Error("Already connected.");if(!this.protocol)throw new Error("The session was never previously connected.");if(this.reconnecting)throw new Error("Already reconnecting.");this.reconnecting=!0;try{await this.reconnectInternal(e,t)}finally{this.reconnecting=!1}}async reconnectInternal(e,t){var n,i,o,r,a,l;const u=this.sessionId,S=this.protocol,w=null===(n=this.kexService)||void 0===n?void 0:n.hostKey;if(!(u&&S&&this.kexService&&w&&(null===(i=S.extensions)||void 0===i?void 0:i.has(h.SshProtocolExtensionNames.sessionReconnect))))throw new Error("Reconnect was not enabled for this session.");let p;try{if(this.sessionId=null,await this.connect(e,t),!this.sessionId||!this.algorithms||!this.algorithms.signer)throw new Error("Session is not encrypted.");const n=this.kexService.hostKey,s=n?await n.getPublicKeyBytes():null,i=await w.getPublicKeyBytes();if(!s||!i||!s.equals(i)){const e="The server host key is different.";throw this.trace(v.TraceLevel.Error,v.SshTraceEventIds.clientSessionReconnectFailed,`Reconnection failed: ${e}`),new d.SshReconnectError(e,c.SshReconnectFailureReason.differentServerHostKey)}p=this.sessionId}catch(e){throw this.protocol=S,super.handleDisconnected(),e}finally{this.sessionId=u,this.kexService.hostKey=w}const R=await this.createReconnectToken(u,p),f=new c.SessionReconnectRequestMessage;f.requestType="session-reconnect@microsoft.com",f.clientReconnectToken=R,f.lastReceivedSequenceNumber=S.lastIncomingSequence,f.wantReply=!0;const g=await this.requestResponse(f,c.SessionReconnectResponseMessage,c.SessionReconnectFailureMessage,t);if(g instanceof c.SessionReconnectFailureMessage){const e=null!==(o=g.reasonCode)&&void 0!==o?o:c.SshReconnectFailureReason.unknownServerFailure,t=null!==(r=g.description)&&void 0!==r?r:"The server rejected the reconnect request.";throw this.trace(v.TraceLevel.Error,v.SshTraceEventIds.clientSessionReconnectFailed,`Reconnection failed: ${t}`),this.protocol=S,new d.SshReconnectError(t,e)}if(!this.verifyReconnectToken(u,p,null!==(a=g.serverReconnectToken)&&void 0!==a?a:s.alloc(0))){const e="The reconnect token provided by the server was invalid.";throw this.trace(v.TraceLevel.Error,v.SshTraceEventIds.clientSessionReconnectFailed,`Reconnection failed: ${e}`),new d.SshReconnectError(e,c.SshReconnectFailureReason.invalidServerReconnectToken)}this.trace(v.TraceLevel.Info,v.SshTraceEventIds.clientSessionReconnecting,"Reconnect request was accepted by the server.");const y=S.getSentMessages((null!==(l=g.lastReceivedSequenceNumber)&&void 0!==l?l:0)+1);if(!y){const e="Client is unable to re-send messages requested by the server.";throw this.trace(v.TraceLevel.Error,v.SshTraceEventIds.clientSessionReconnectFailed,`Reconnection failed: ${e}`),new d.SshReconnectError(e,c.SshReconnectFailureReason.clientDroppedMessages)}let m=0;for(const e of y)await this.sendMessage(e,t),m++;S.dispose(),this.metrics.addReconnection(),this.trace(v.TraceLevel.Info,v.SshTraceEventIds.clientSessionReconnecting,`${this} reconnected. Re-sent ${m} dropped messages.`)}dispose(){this.clientAuthCompletion&&this.clientAuthCompletion.reject(new d.ObjectDisposedError(this)),super.dispose()}}t.SshClientSession=S},51485:(e,t,n)=>{var s=n(30816).Buffer;Object.defineProperty(t,"__esModule",{value:!0}),t.SshClientSession=void 0;const i=n(7395),c=n(90818),o=n(28047),r=n(93708),a=n(97437),h=n(97183),l=n(76502),u=n(47165),d=n(72917),v=n(43776);class S extends i.SshSession{constructor(e){super(e,!0),this.serviceRequests=new Map,this.clientAuthCompletion=null}async authenticate(e,t){if(!await this.authenticateServer(t))return!1;return!!await this.authenticateClient(e,t)}async authenticateServer(e){if(!this.kexService||!this.kexService.hostKey)throw new Error("Encrypt the session before authenticating.");try{this.principal=await this.raiseAuthenticatingEvent(new o.SshAuthenticatingEventArgs(o.SshAuthenticationType.serverPublicKey,{publicKey:this.kexService.hostKey},e))}catch(e){if(!(e instanceof Error))throw e;throw this.trace(v.TraceLevel.Error,v.SshTraceEventIds.authenticationError,`Error while authenticating server: ${e.message}`,e),e}return this.principal?(this.trace(v.TraceLevel.Info,v.SshTraceEventIds.sessionAuthenticated,`${this} server authenticated.`),!0):(await this.close(c.SshDisconnectReason.hostKeyNotVerifiable,"Server authentication failed."),this.trace(v.TraceLevel.Warning,v.SshTraceEventIds.serverAuthenticationFailed,`${this} server authentication failed.`),!1)}authenticateClient(e,t,n){if(!e)throw new TypeError("A credentials object is required.");return"function"==typeof t?this.authenticateClientWithCompletion(e,t,n):new Promise((async(n,s)=>{await this.authenticateClientWithCompletion(e,((e,t)=>{e?s(e):n(t)}),t)}))}async authenticateClientWithCompletion(e,t,n){if(this.clientAuthCompletion=new r.PromiseCompletionSource,this.clientAuthCompletion.promise.then((e=>t(void 0,e)),(e=>t(e))),n){if(n.isCancellationRequested)throw new a.CancellationError;n.onCancellationRequested((e=>{this.clientAuthCompletion&&this.clientAuthCompletion.reject(new a.CancellationError)}))}let s=this.getService(l.AuthenticationService);if(!s){const e=new c.ServiceRequestMessage;e.serviceName=l.AuthenticationService.serviceName,await this.sendMessage(e,n),s=this.activateService(l.AuthenticationService)}await s.authenticateClient(e,n)}onAuthenticationComplete(e){e?this.trace(v.TraceLevel.Info,v.SshTraceEventIds.sessionAuthenticated,`${this} client authenticated.`):this.trace(v.TraceLevel.Warning,v.SshTraceEventIds.clientAuthenticationFailed,`${this} client authentication failed.`),this.clientAuthCompletion&&(this.clientAuthCompletion.resolve(e),this.clientAuthCompletion=null)}async requestService(e,t){let n=!1,s=this.serviceRequests.get(e);if(s||(s=new r.PromiseCompletionSource,this.serviceRequests.set(e,s),n=!0),n){const n=new c.ServiceRequestMessage;n.serviceName=e,await this.sendMessage(n,t)}await s.promise}async handleServiceAcceptMessage(e,t){const n=this.serviceRequests.get(e.serviceName);null==n||n.resolve(!0)}async openChannel(e,t,n){if(!this.connectionService){const e=new c.ServiceRequestMessage;e.serviceName=u.ConnectionService.serviceName,await this.sendMessage(e,n)}return await super.openChannel(e,t,n)}handleDisconnected(){return this.reconnecting?(this.reconnecting=!1,!1):super.handleDisconnected()}async reconnect(e,t){if(this.trace(v.TraceLevel.Verbose,v.SshTraceEventIds.clientSessionReconnecting,"Attempting to reconnect..."),this.isClosed)throw new d.ObjectDisposedError(this);if(this.isConnected)throw new Error("Already connected.");if(!this.protocol)throw new Error("The session was never previously connected.");if(this.reconnecting)throw new Error("Already reconnecting.");this.reconnecting=!0;try{await this.reconnectInternal(e,t)}finally{this.reconnecting=!1}}async reconnectInternal(e,t){var n,i,o,r,a,l;const u=this.sessionId,S=this.protocol,w=null===(n=this.kexService)||void 0===n?void 0:n.hostKey;if(!(u&&S&&this.kexService&&w&&(null===(i=S.extensions)||void 0===i?void 0:i.has(h.SshProtocolExtensionNames.sessionReconnect))))throw new Error("Reconnect was not enabled for this session.");let p;try{if(this.sessionId=null,await this.connect(e,t),!this.sessionId||!this.algorithms||!this.algorithms.signer)throw new Error("Session is not encrypted.");const n=this.kexService.hostKey,s=n?await n.getPublicKeyBytes():null,i=await w.getPublicKeyBytes();if(!s||!i||!s.equals(i)){const e="The server host key is different.";throw this.trace(v.TraceLevel.Error,v.SshTraceEventIds.clientSessionReconnectFailed,`Reconnection failed: ${e}`),new d.SshReconnectError(e,c.SshReconnectFailureReason.differentServerHostKey)}p=this.sessionId}catch(e){throw this.protocol=S,super.handleDisconnected(),e}finally{this.sessionId=u,this.kexService.hostKey=w}const R=await this.createReconnectToken(u,p),f=new c.SessionReconnectRequestMessage;f.requestType="session-reconnect@microsoft.com",f.clientReconnectToken=R,f.lastReceivedSequenceNumber=S.lastIncomingSequence,f.wantReply=!0;const g=await this.requestResponse(f,c.SessionReconnectResponseMessage,c.SessionReconnectFailureMessage,t);if(g instanceof c.SessionReconnectFailureMessage){const e=null!==(o=g.reasonCode)&&void 0!==o?o:c.SshReconnectFailureReason.unknownServerFailure,t=null!==(r=g.description)&&void 0!==r?r:"The server rejected the reconnect request.";throw this.trace(v.TraceLevel.Error,v.SshTraceEventIds.clientSessionReconnectFailed,`Reconnection failed: ${t}`),this.protocol=S,new d.SshReconnectError(t,e)}if(!this.verifyReconnectToken(u,p,null!==(a=g.serverReconnectToken)&&void 0!==a?a:s.alloc(0))){const e="The reconnect token provided by the server was invalid.";throw this.trace(v.TraceLevel.Error,v.SshTraceEventIds.clientSessionReconnectFailed,`Reconnection failed: ${e}`),new d.SshReconnectError(e,c.SshReconnectFailureReason.invalidServerReconnectToken)}this.trace(v.TraceLevel.Info,v.SshTraceEventIds.clientSessionReconnecting,"Reconnect request was accepted by the server.");const y=S.getSentMessages((null!==(l=g.lastReceivedSequenceNumber)&&void 0!==l?l:0)+1);if(!y){const e="Client is unable to re-send messages requested by the server.";throw this.trace(v.TraceLevel.Error,v.SshTraceEventIds.clientSessionReconnectFailed,`Reconnection failed: ${e}`),new d.SshReconnectError(e,c.SshReconnectFailureReason.clientDroppedMessages)}let m=0;for(let e of y)await this.sendMessage(e,t),m++;S.dispose(),this.metrics.addReconnection(),this.trace(v.TraceLevel.Info,v.SshTraceEventIds.clientSessionReconnecting,`{this} reconnected. Re-sent ${m} dropped messages.`)}dispose(){this.clientAuthCompletion&&this.clientAuthCompletion.reject(new d.ObjectDisposedError(this)),super.dispose()}}t.SshClientSession=S}}]);