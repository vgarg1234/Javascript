"use strict";(self.webpackChunkcodespaces_web_client=self.webpackChunkcodespaces_web_client||[]).push([[960],{85523:(e,t,s)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.SshProtocol=void 0;const n=s(30816),i=s(85670),r=s(62777),a=s(4432),o=s(3364),c=s(81978),h=s(56485),l=s(36149),u=s(77316),d=s(70158);class g{constructor(e,t){this.sequence=e,this.message=t}}class m{constructor(e,t,s,a){this.config=t,this.metrics=s,this.trace=a,this.sessionSemaphore=new r.Semaphore(1),this.inboundPacketSequence=0,this.outboundPacketSequence=0,this.inboundFlow=0,this.outboundFlow=0,this.recentSentMessages=new i.Queue,this.sendWriter=new o.SshDataWriter(n.Buffer.alloc(1024)),this.receiveWriter=new o.SshDataWriter(n.Buffer.alloc(1024)),this.traceChannelData=!1,this.extensions=null,this.kexService=null,this.algorithms=null,this.messageContext=null,this.outgoingMessagesHaveLatencyInfo=!1,this.incomingMessagesHaveLatencyInfo=!1,this.outgoingMessagesHaveReconnectInfo=!1,this.incomingMessagesHaveReconnectInfo=!1,this.stream=e,this.traceChannelData=t.traceChannelData}get lastIncomingSequence(){return this.inboundPacketSequence-1}getSentMessages(e){if(e===this.outboundPacketSequence+1)return[];if(this.recentSentMessages.size>0&&e<this.recentSentMessages.peek().sequence)return null;const t=new Array;for(const s of this.recentSentMessages)if(s.sequence>=e){const e=s.message;e instanceof h.KeyExchangeMessage||e instanceof c.DisconnectMessage||t.push(e)}return t}async writeProtocolVersion(e,t){const s=this.stream;if(!s)throw new Error("SSH session disconnected.");const i=n.Buffer.from(e+"\r\n");return await s.write(i,t),this.metrics.addMessageSent(i.length),Promise.resolve()}async readProtocolVersion(e){const t=this.stream;if(!t)throw new Error("SSH session disconnected.");const s=n.Buffer.alloc(255);let i=0;for(let n=0;n<s.length;n++){const r=await t.read(1,e);if(!r)break;s[n]=r[0];const a=13,o=10;if(n>0&&s[n-1]===a&&s[n]===o){const e=s.toString("utf8",0,n-1);if(e.startsWith("SSH-"))return this.metrics.addMessageReceived(n+1),e;if(i>20)break;i++,n=-1}}throw new u.SshConnectionError("Failed to read the protocol version",c.SshDisconnectReason.protocolError)}async handleNewKeys(e){try{await this.sessionSemaphore.wait(e),this.inboundFlow=0,this.outboundFlow=0,this.algorithms=this.kexService.finishKeyExchange()}finally{this.sessionSemaphore.release()}}async read(e,t){const s=this.stream;if(!s)return!1;let n=0;do{let i;try{i=await s.read(e.length-n,t)}catch(e){if(!(e instanceof Error))throw e;if(s.isDisposed)return!1;throw s.dispose(),this.stream=null,this.trace(d.TraceLevel.Error,d.SshTraceEventIds.streamReadError,`Error reading from stream: ${e.message}`,e),new u.SshConnectionError("Error reading from stream: "+e.message,c.SshDisconnectReason.connectionLost)}if(!i)return!1;i.copy(e,n),n+=i.length}while(n<e.length);return!0}async write(e,t){const s=this.stream;if(!s)return!1;try{await s.write(e,t)}catch(e){if(!(e instanceof Error))throw e;if(s.isDisposed)return!1;throw s.dispose(),this.stream=null,this.trace(d.TraceLevel.Error,d.SshTraceEventIds.streamWriteError,`Error writing to stream: ${e.message}`,e),new u.SshConnectionError("Error writing to stream: "+e.message,c.SshDisconnectReason.connectionLost)}return!0}async considerReExchange(e,t){const s=this.kexService;if(!s)return;let n=null,i=null;!s.exchanging&&(e||this.inboundFlow+this.outboundFlow>this.config.keyRotationThreshold)&&([n,i]=await s.startKeyExchange(e)),n&&(await this.sendMessage(n,t),i&&await this.sendMessage(i,t))}async computeHmac(e,t,s){const i=new o.SshDataWriter(n.Buffer.alloc(4+t.length));i.writeUInt32(s),i.write(t);return await e.sign(i.toBuffer())}async verifyHmac(e,t,s,i){const r=new o.SshDataWriter(n.Buffer.alloc(4+t.length));r.writeUInt32(s),r.write(t);return await e.verify(r.toBuffer(),i)}async readAndVerifyHmac(e,t,s,n){if(!await this.read(s,n))return!1;if(!await this.verifyHmac(e,t,this.inboundPacketSequence,s))throw new u.SshConnectionError("Invalid MAC",c.SshDisconnectReason.macError);return!0}async sendMessage(e,t){var s;const i=this.algorithms,r=null==i?void 0:i.compressor,a=null==i?void 0:i.cipher,o=null==i?void 0:i.messageSigner;let c;await this.sessionSemaphore.wait(t);try{const i=a?Math.max(8,a.blockLength):8,h=m.packetLengthSize+m.paddingLengthSize;if(this.sendWriter.position=h,e.write(this.sendWriter),this.outgoingMessagesHaveReconnectInfo&&(this.sendWriter.writeUInt64(this.lastIncomingSequence),this.outgoingMessagesHaveLatencyInfo)){const e=Math.min(4294967295,Math.round(1e3*(this.metrics.time-this.lastIncomingTimestamp)));this.sendWriter.writeUInt32(e)}let u=this.sendWriter.toBuffer().slice(h);null!=r&&(u=r.compress(u));let f=i-((!((null==o?void 0:o.encryptThenMac)||(null==o?void 0:o.authenticatedEncryption))?m.packetLengthSize:0)+m.paddingLengthSize+u.length)%i;f<4&&(f+=i);const w=m.paddingLengthSize+u.length+f;this.sendWriter.position=0,this.sendWriter.writeUInt32(w),this.sendWriter.writeByte(f),null!=r?this.sendWriter.write(u):this.sendWriter.position+=u.length,this.sendWriter.writeRandom(f),u=this.sendWriter.toBuffer();let S=null;if((null==o?void 0:o.encryptThenMac)&&a){const e=u.slice(m.packetLengthSize,u.length);(await a.transform(e)).copy(e),S=await this.computeHmac(o,u,this.outboundPacketSequence)}else if(null==o?void 0:o.authenticatedEncryption){const e=u.slice(m.packetLengthSize,u.length);(await a.transform(e)).copy(e),S=await o.sign(e)}else o&&(S=await this.computeHmac(o,u,this.outboundPacketSequence)),a&&(u=await a.transform(u));if(e instanceof l.ChannelDataMessage?this.traceChannelData&&this.trace(d.TraceLevel.Verbose,d.SshTraceEventIds.sendingChannelData,`Sending #${this.outboundPacketSequence} ${e}`):this.trace(d.TraceLevel.Verbose,d.SshTraceEventIds.sendingMessage,`Sending #${this.outboundPacketSequence} ${e}`),this.incomingMessagesHaveReconnectInfo){const t=new g(this.outboundPacketSequence,e);t.sentTime=this.metrics.time,this.recentSentMessages.enqueue(t)}if(this.outboundPacketSequence++,this.outboundFlow+=w,S){const e=n.Buffer.concat([u,S],u.length+S.length);c=await this.write(e,t)}else c=await this.write(u,t);this.metrics.addMessageSent(m.packetLengthSize+w+(null!==(s=null==o?void 0:o.digestLength)&&void 0!==s?s:0))}finally{this.sessionSemaphore.release()}return await this.considerReExchange(!1,t),c}async receiveMessage(e){var t;const s=this.algorithms,n=null==s?void 0:s.decipher,i=null==s?void 0:s.messageVerifier,r=null==s?void 0:s.decompressor,h=!((null==i?void 0:i.encryptThenMac)||(null==i?void 0:i.authenticatedEncryption)),g=h?n?Math.max(8,n.blockLength):8:m.packetLengthSize;this.receiveWriter.position=g;let f=this.receiveWriter.toBuffer();if(!await this.read(f,e))return null;this.lastIncomingTimestamp=this.metrics.time,n&&h&&(f=await n.transform(f),this.receiveWriter.position=0,this.receiveWriter.write(f));const w=new o.SshDataReader(f).readUInt32();if(w>m.maxPacketLength)throw new u.SshConnectionError("Invalid packet length.",c.SshDisconnectReason.protocolError);const S=m.packetLengthSize+w;S>g&&this.receiveWriter.skip(S-g),i&&this.receiveWriter.skip(i.digestLength);const p=this.receiveWriter.toBuffer(),v=p.slice(0,S),y=p.slice(S);let E=v.slice(g,S);if(E.length>0){if(!await this.read(E,e))return null;if((null==i?void 0:i.encryptThenMac)&&!await this.readAndVerifyHmac(i,v,y,e))return null;if(n){if(null==i?void 0:i.authenticatedEncryption){if(!await this.read(y,e))return null;await i.verify(E,y)}try{E=await n.transform(E)}catch(e){throw(null==i?void 0:i.authenticatedEncryption)?new u.SshConnectionError("Invalid MAC",c.SshDisconnectReason.macError):e}this.receiveWriter.position=g,this.receiveWriter.write(E)}}if(i&&!i.encryptThenMac&&!i.authenticatedEncryption&&!await this.readAndVerifyHmac(i,v,y,e))return null;const M=v[m.packetLengthSize];let k=v.slice(m.packetLengthSize+m.paddingLengthSize,m.packetLengthSize+(w-M));if(r&&(k=r.decompress(k)),this.incomingMessagesHaveReconnectInfo){let e,t;if(this.incomingMessagesHaveLatencyInfo){const s=new o.SshDataReader(k.slice(k.length-12,k.length));e=s.readUInt64(),t=s.readUInt32()/1e3,k=k.slice(0,k.length-12)}else{e=new o.SshDataReader(k.slice(k.length-8,k.length)).readUInt64(),t=0,k=k.slice(0,k.length-8)}for(;this.recentSentMessages.size>0;){const s=this.recentSentMessages.peek();if(s.sequence>e)break;if(this.stream&&this.incomingMessagesHaveLatencyInfo&&s.sequence===e){const e=this.lastIncomingTimestamp-s.sentTime-t;this.metrics.updateLatency(e,this.trace)}this.recentSentMessages.dequeue()}}const L=k[0];let b=a.SshMessage.create(this.config,L,this.messageContext,k);if(!b){const e=new c.UnimplementedMessage;e.sequenceNumber=this.inboundPacketSequence,e.unimplementedMessageType=L,b=e}return b instanceof l.ChannelDataMessage?this.traceChannelData&&this.trace(d.TraceLevel.Verbose,d.SshTraceEventIds.receivingChannelData,`Receiving #${this.inboundPacketSequence} ${b}`):this.trace(d.TraceLevel.Verbose,d.SshTraceEventIds.receivingMessage,`Receiving #${this.inboundPacketSequence} ${b}`),await this.sessionSemaphore.wait(e),this.inboundPacketSequence++,this.inboundFlow+=w,this.sessionSemaphore.release(),this.metrics.addMessageReceived(m.packetLengthSize+w+(null!==(t=null==i?void 0:i.digestLength)&&void 0!==t?t:0)),await this.considerReExchange(!1,e),b}dispose(){try{this.stream&&this.stream.close().catch((e=>{this.trace(d.TraceLevel.Error,d.SshTraceEventIds.streamCloseError,`Error closing stream: ${e.message}`,e)}))}catch(e){if(!(e instanceof Error))throw e;this.trace(d.TraceLevel.Error,d.SshTraceEventIds.streamCloseError,`Error closing stream: ${e.message}`,e)}this.stream=null,this.metrics.updateLatency(0),this.algorithms&&this.algorithms.dispose()}}t.SshProtocol=m,m.maxPacketLength=1048576,m.packetLengthSize=4,m.paddingLengthSize=1},17585:(e,t,s)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.SshProtocol=void 0;const n=s(30816),i=s(28776),r=s(24564),a=s(285),o=s(67914),c=s(90818),h=s(50856),l=s(45757),u=s(72917),d=s(43776);class g{constructor(e,t){this.sequence=e,this.message=t}}class m{constructor(e,t,s,a){this.config=t,this.metrics=s,this.trace=a,this.sessionSemaphore=new r.Semaphore(1),this.inboundPacketSequence=0,this.outboundPacketSequence=0,this.inboundFlow=0,this.outboundFlow=0,this.recentSentMessages=new i.Queue,this.sendWriter=new o.SshDataWriter(n.Buffer.alloc(1024)),this.receiveWriter=new o.SshDataWriter(n.Buffer.alloc(1024)),this.traceChannelData=!1,this.extensions=null,this.kexService=null,this.algorithms=null,this.outgoingMessagesHaveLatencyInfo=!1,this.incomingMessagesHaveLatencyInfo=!1,this.outgoingMessagesHaveReconnectInfo=!1,this.incomingMessagesHaveReconnectInfo=!1,this.stream=e}get lastIncomingSequence(){return this.inboundPacketSequence-1}getSentMessages(e){if(e===this.outboundPacketSequence+1)return[];if(this.recentSentMessages.size>0&&e<this.recentSentMessages.peek().sequence)return null;const t=new Array;for(let s of this.recentSentMessages)if(s.sequence>=e){const e=s.message;e instanceof h.KeyExchangeMessage||e instanceof c.DisconnectMessage||t.push(e)}return t}async writeProtocolVersion(e,t){const s=this.stream;if(!s)throw new Error("SSH session disconnected.");const i=n.Buffer.from(e+"\r\n");return await s.write(i,t),this.metrics.addMessageSent(i.length),Promise.resolve()}async readProtocolVersion(e){const t=this.stream;if(!t)throw new Error("SSH session disconnected.");const s=n.Buffer.alloc(255);let i=0;for(let n=0;n<s.length;n++){const r=await t.read(1,e);if(!r)break;s[n]=r[0];const a=13,o=10;if(n>0&&s[n-1]===a&&s[n]===o){const e=s.toString("utf8",0,n-1);if(e.startsWith("SSH-"))return this.metrics.addMessageReceived(n+1),e;if(i>20)break;i++,n=-1}}throw new u.SshConnectionError("Failed to read the protocol version",c.SshDisconnectReason.protocolError)}async handleNewKeys(e){try{await this.sessionSemaphore.wait(e),this.inboundFlow=0,this.outboundFlow=0,this.algorithms=this.kexService.finishKeyExchange()}finally{this.sessionSemaphore.release()}}async read(e,t){const s=this.stream;if(!s)return!1;let n=0;do{let i;try{i=await s.read(e.length-n,t)}catch(e){if(!(e instanceof Error))throw e;if(s.isDisposed)return!1;throw s.dispose(),this.stream=null,this.trace(d.TraceLevel.Error,d.SshTraceEventIds.streamReadError,`Error reading from stream: ${e.message}`,e),new u.SshConnectionError("Error reading from stream: "+e.message,c.SshDisconnectReason.connectionLost)}if(!i)return!1;i.copy(e,n),n+=i.length}while(n<e.length);return!0}async write(e,t){const s=this.stream;if(!s)return!1;try{await s.write(e,t)}catch(e){if(!(e instanceof Error))throw e;if(s.isDisposed)return!1;throw s.dispose(),this.stream=null,this.trace(d.TraceLevel.Error,d.SshTraceEventIds.streamWriteError,`Error writing to stream: ${e.message}`,e),new u.SshConnectionError("Error writing to stream: "+e.message,c.SshDisconnectReason.connectionLost)}return!0}async considerReExchange(e,t){const s=this.kexService;if(!s)return;let n=null,i=null;!s.exchanging&&(e||this.inboundFlow+this.outboundFlow>this.config.keyRotationThreshold)&&([n,i]=await s.startKeyExchange(e)),n&&(await this.sendMessage(n,t),i&&await this.sendMessage(i,t))}async computeHmac(e,t,s){const i=new o.SshDataWriter(n.Buffer.alloc(4+t.length));i.writeUInt32(s),i.write(t);return await e.sign(i.toBuffer())}async verifyHmac(e,t,s,i){const r=new o.SshDataWriter(n.Buffer.alloc(4+t.length));r.writeUInt32(s),r.write(t);return await e.verify(r.toBuffer(),i)}async readAndVerifyHmac(e,t,s,n){if(!await this.read(s,n))return!1;if(!await this.verifyHmac(e,t,this.inboundPacketSequence,s))throw new u.SshConnectionError("Invalid MAC",c.SshDisconnectReason.macError);return!0}async sendMessage(e,t){var s;const i=this.algorithms,r=null==i?void 0:i.compressor,a=null==i?void 0:i.cipher,o=null==i?void 0:i.messageSigner;let c;await this.sessionSemaphore.wait(t);try{const i=a?Math.max(8,a.blockLength):8,h=m.packetLengthSize+m.paddingLengthSize;if(this.sendWriter.position=h,e.write(this.sendWriter),this.outgoingMessagesHaveReconnectInfo&&(this.sendWriter.writeUInt64(this.lastIncomingSequence),this.outgoingMessagesHaveLatencyInfo)){const e=Math.min(4294967295,Math.round(1e3*(this.metrics.time-this.lastIncomingTimestamp)));this.sendWriter.writeUInt32(e)}let u=this.sendWriter.toBuffer().slice(h);null!=r&&(u=r.compress(u));let f=i-((!((null==o?void 0:o.encryptThenMac)||(null==o?void 0:o.authenticatedEncryption))?m.packetLengthSize:0)+m.paddingLengthSize+u.length)%i;f<4&&(f+=i);const w=m.paddingLengthSize+u.length+f;this.sendWriter.position=0,this.sendWriter.writeUInt32(w),this.sendWriter.writeByte(f),null!=r?this.sendWriter.write(u):this.sendWriter.position+=u.length,this.sendWriter.writeRandom(f),u=this.sendWriter.toBuffer();let S=null;if((null==o?void 0:o.encryptThenMac)&&a){const e=u.slice(m.packetLengthSize,u.length);(await a.transform(e)).copy(e),S=await this.computeHmac(o,u,this.outboundPacketSequence)}else if(null==o?void 0:o.authenticatedEncryption){let e=u.slice(m.packetLengthSize,u.length);(await a.transform(e)).copy(e),S=await o.sign(e)}else o&&(S=await this.computeHmac(o,u,this.outboundPacketSequence)),a&&(u=await a.transform(u));if(e instanceof l.ChannelDataMessage?this.traceChannelData&&this.trace(d.TraceLevel.Verbose,d.SshTraceEventIds.sendingChannelData,`Sending #${this.outboundPacketSequence} ${e}`):this.trace(d.TraceLevel.Verbose,d.SshTraceEventIds.sendingMessage,`Sending #${this.outboundPacketSequence} ${e}`),this.incomingMessagesHaveReconnectInfo){const t=new g(this.outboundPacketSequence,e);t.sentTime=this.metrics.time,this.recentSentMessages.enqueue(t)}if(this.outboundPacketSequence++,this.outboundFlow+=w,S){const e=n.Buffer.concat([u,S],u.length+S.length);c=await this.write(e,t)}else c=await this.write(u,t);this.metrics.addMessageSent(m.packetLengthSize+w+(null!==(s=null==o?void 0:o.digestLength)&&void 0!==s?s:0))}finally{this.sessionSemaphore.release()}return await this.considerReExchange(!1,t),c}async receiveMessage(e){var t;const s=this.algorithms,n=null==s?void 0:s.decipher,i=null==s?void 0:s.messageVerifier,r=null==s?void 0:s.decompressor,h=!((null==i?void 0:i.encryptThenMac)||(null==i?void 0:i.authenticatedEncryption)),g=h?n?Math.max(8,n.blockLength):8:m.packetLengthSize;this.receiveWriter.position=g;let f=this.receiveWriter.toBuffer();if(!await this.read(f,e))return null;this.lastIncomingTimestamp=this.metrics.time,n&&h&&(f=await n.transform(f),this.receiveWriter.position=0,this.receiveWriter.write(f));const w=new o.SshDataReader(f).readUInt32();if(w>m.maxPacketLength)throw new u.SshConnectionError("Invalid packet length.",c.SshDisconnectReason.protocolError);const S=m.packetLengthSize+w;S>g&&this.receiveWriter.skip(S-g),i&&this.receiveWriter.skip(i.digestLength);const p=this.receiveWriter.toBuffer(),v=p.slice(0,S),y=p.slice(S);let E=v.slice(g,S);if(E.length>0){if(!await this.read(E,e))return null;if((null==i?void 0:i.encryptThenMac)&&!await this.readAndVerifyHmac(i,v,y,e))return null;if(n){if(null==i?void 0:i.authenticatedEncryption){if(!await this.read(y,e))return null;await i.verify(E,y)}try{E=await n.transform(E)}catch(e){throw(null==i?void 0:i.authenticatedEncryption)?new u.SshConnectionError("Invalid MAC",c.SshDisconnectReason.macError):e}this.receiveWriter.position=g,this.receiveWriter.write(E)}}if(i&&!i.encryptThenMac&&!i.authenticatedEncryption&&!await this.readAndVerifyHmac(i,v,y,e))return null;const M=v[m.packetLengthSize];let k=v.slice(m.packetLengthSize+m.paddingLengthSize,m.packetLengthSize+(w-M));if(r&&(k=r.decompress(k)),this.incomingMessagesHaveReconnectInfo){let e,t;if(this.incomingMessagesHaveLatencyInfo){const s=new o.SshDataReader(k.slice(k.length-12,k.length));e=s.readUInt64(),t=s.readUInt32()/1e3,k=k.slice(0,k.length-12)}else{e=new o.SshDataReader(k.slice(k.length-8,k.length)).readUInt64(),t=0,k=k.slice(0,k.length-8)}for(;this.recentSentMessages.size>0;){const s=this.recentSentMessages.peek();if(s.sequence>e)break;if(this.stream&&this.incomingMessagesHaveLatencyInfo&&s.sequence===e){const e=this.lastIncomingTimestamp-s.sentTime-t;this.metrics.updateLatency(e)}this.recentSentMessages.dequeue()}}const L=k[0];let b=a.SshMessage.create(this.config,L,k);if(!b){const e=new c.UnimplementedMessage;e.sequenceNumber=this.inboundPacketSequence,e.unimplementedMessageType=L,b=e}return b instanceof l.ChannelDataMessage?this.traceChannelData&&this.trace(d.TraceLevel.Verbose,d.SshTraceEventIds.receivingChannelData,`Receiving #${this.inboundPacketSequence} ${b}`):this.trace(d.TraceLevel.Verbose,d.SshTraceEventIds.receivingMessage,`Receiving #${this.inboundPacketSequence} ${b}`),await this.sessionSemaphore.wait(e),this.inboundPacketSequence++,this.inboundFlow+=w,this.sessionSemaphore.release(),this.metrics.addMessageReceived(m.packetLengthSize+w+(null!==(t=null==i?void 0:i.digestLength)&&void 0!==t?t:0)),await this.considerReExchange(!1,e),b}dispose(){try{this.stream&&this.stream.close().catch((e=>{this.trace(d.TraceLevel.Error,d.SshTraceEventIds.streamCloseError,`Error closing stream: ${e.message}`,e)}))}catch(e){if(!(e instanceof Error))throw e;this.trace(d.TraceLevel.Error,d.SshTraceEventIds.streamCloseError,`Error closing stream: ${e.message}`,e)}this.stream=null,this.metrics.updateLatency(0),this.algorithms&&this.algorithms.dispose()}}t.SshProtocol=m,m.maxPacketLength=1048576,m.packetLengthSize=4,m.paddingLengthSize=1}}]);