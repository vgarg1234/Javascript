"use strict";(self.webpackChunkcodespaces_web_client=self.webpackChunkcodespaces_web_client||[]).push([[488],{99618:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.TunnelManagementHttpClient=void 0;const s=n(11536),r=n(7608),o=n(89116),i=n(62500),a=n(14206),u="/api/v1",c=u+"/tunnels",l="/endpoints",d="/ports",p=u+"/clusters",h="Authorization";function T(e,t){var n,s;return(null!==(n=e.portNumber)&&void 0!==n?n:Number.MAX_SAFE_INTEGER)-(null!==(s=t.portNumber)&&void 0!==s?s:Number.MAX_SAFE_INTEGER)}function v(e){return"string"==typeof e?new Date(Date.parse(e)):e}function g(e){e&&(e.created=v(e.created),e.status&&(e.status.lastHostConnectionTime=v(e.status.lastHostConnectionTime),e.status.lastClientConnectionTime=v(e.status.lastClientConnectionTime)))}function f(e){e&&e.status&&(e.status.lastClientConnectionTime=v(e.status.lastClientConnectionTime))}const m=[s.TunnelAccessScopes.Manage],$=[s.TunnelAccessScopes.Host],w=[s.TunnelAccessScopes.Manage,s.TunnelAccessScopes.ManagePorts,s.TunnelAccessScopes.Host],A=[s.TunnelAccessScopes.Manage,s.TunnelAccessScopes.ManagePorts,s.TunnelAccessScopes.Host,s.TunnelAccessScopes.Connect];class y{constructor(e,t,n,r){var o;if(this.httpsAgent=r,this.trace=e=>{},!e)throw new TypeError("User agent must be provided.");if(Array.isArray(e)){if(0===e.length)throw new TypeError("User agents cannot be empty.");let t="";e.forEach((e=>{var n;if("string"!=typeof e){if(!e.name)throw new TypeError("Invalid user agent. The name must be provided.");if("string"!=typeof e.name)throw new TypeError("Invalid user agent. The name must be a string.");if(e.version&&"string"!=typeof e.version)throw new TypeError("Invalid user agent. The version must be a string.");t=`${t}${e.name}/${null!==(n=e.version)&&void 0!==n?n:"unknown"} `}else t=`${t}${e} `})),this.userAgents=t.trim()}else if("string"!=typeof e){if(!e.name)throw new TypeError("Invalid user agent. The name must be provided.");if("string"!=typeof e.name)throw new TypeError("Invalid user agent. The name must be a string.");if(e.version&&"string"!=typeof e.version)throw new TypeError("Invalid user agent. The version must be a string.");this.userAgents=`${e.name}/${null!==(o=e.version)&&void 0!==o?o:"unknown"}`}else this.userAgents=e;this.userTokenCallback=null!=t?t:()=>Promise.resolve(null),n||(n=s.TunnelServiceProperties.production.serviceUri);const i=new URL(n);if(!i||"/"!==i.pathname)throw new TypeError(`Invalid tunnel service URI: ${n}`);this.baseAddress=n}async listTunnels(e,t,n){const s=[e?null:"global=true",t?`domain=${t}`:null].filter((e=>!!e)).join("&"),r=await this.sendRequest("GET",e,c,s,n);return r.forEach(g),r}async getTunnel(e,t){const n=await this.sendTunnelRequest("GET",e,A,void 0,void 0,t);return g(n),n}async createTunnel(e,t){if(e.tunnelId)throw new Error("An ID may not be specified when creating a tunnel.");e=this.convertTunnelForRequest(e);const n=await this.sendRequest("POST",e.clusterId,c,void 0,t,e);return g(n),n}async updateTunnel(e,t){const n=await this.sendTunnelRequest("PUT",e,m,void 0,void 0,t,this.convertTunnelForRequest(e));return(null==t?void 0:t.tokenScopes)||(n.accessTokens=e.accessTokens),g(n),n}async deleteTunnel(e,t){return await this.sendTunnelRequest("DELETE",e,m,void 0,void 0,t,void 0,!0)}async updateTunnelEndpoint(e,t,n){const s=`${l}/${t.hostId}/${t.connectionMode}`,r=await this.sendTunnelRequest("PUT",e,$,s,void 0,n,t);return e.endpoints&&(e.endpoints=e.endpoints.filter((e=>e.hostId!==t.hostId||e.connectionMode!==t.connectionMode)).concat(r)),r}async deleteTunnelEndpoints(e,t,n,s){const r=null==n?`${l}/${t}`:`${l}/${t}/${n}`,o=await this.sendTunnelRequest("DELETE",e,$,r,void 0,s,void 0,!0);return o&&e.endpoints&&(e.endpoints=e.endpoints.filter((e=>e.hostId!==t||e.connectionMode!==n))),o}async listTunnelPorts(e,t){const n=await this.sendTunnelRequest("GET",e,A,d,void 0,t);return n.forEach(f),n}async getTunnelPort(e,t,n){const s=`${d}/${t}`,r=await this.sendTunnelRequest("GET",e,A,s,void 0,n);return f(r),r}async createTunnelPort(e,t,n){t=this.convertTunnelPortForRequest(e,t);const s=await this.sendTunnelRequest("POST",e,w,d,void 0,n,t);return e.ports&&(e.ports=e.ports.filter((e=>e.portNumber!==t.portNumber)).concat(s).sort(T)),f(s),s}async updateTunnelPort(e,t,n){if(t.clusterId&&e.clusterId&&t.clusterId!==e.clusterId)throw new Error("Tunnel port cluster ID is not consistent.");const s=t.portNumber,r=`${d}/${s}`;t=this.convertTunnelPortForRequest(e,t);const o=await this.sendTunnelRequest("PUT",e,w,r,void 0,n,t);return e.ports&&(e.ports=e.ports.filter((e=>e.portNumber!==t.portNumber)).concat(o).sort(T)),(null==n?void 0:n.tokenScopes)||(o.accessTokens=t.accessTokens),f(o),o}async deleteTunnelPort(e,t,n){const s=`${d}/${t}`,r=await this.sendTunnelRequest("DELETE",e,w,s,void 0,n,void 0,!0);return r&&e.ports&&(e.ports=e.ports.filter((e=>e.portNumber!==t)).sort(T)),r}async listClusters(){return await this.sendRequest("GET",void 0,p,void 0,void 0,void 0,!1)}async sendTunnelRequest(e,t,n,s,r,o,i,a){const u=this.buildUriForTunnel(t,s,r,o),c=await this.getAxiosRequestConfig(t,o,n);return await this.request(e,u,i,c,a)}async sendRequest(e,t,n,s,r,o,i){const a=this.buildUri(t,n,s,r),u=await this.getAxiosRequestConfig(void 0,r);return await this.request(e,a,o,u,i)}async checkNameAvailablility(e){e=encodeURI(e);const t=this.buildUri(void 0,`${c}/${e}/checkAvailability`),n={httpsAgent:this.httpsAgent};return await this.request("GET",t,void 0,n)}getResponseErrorMessage(e){var t,n,s,r;let o="";if(null===(t=e.response)||void 0===t?void 0:t.data){const t=e.response.data;(t.title||t.detail)&&(o=`Tunnel service error: ${t.title}`,t.detail&&(o+=" "+t.detail),t.errors&&(o+=JSON.stringify(t.errors)))}o||(o=(null==e?void 0:e.response)?`Tunnel service returned status code: ${e.response.status} ${e.response.statusText}`:null!==(s=null!==(n=null==e?void 0:e.message)&&void 0!==n?n:e)&&void 0!==s?s:"Unknown tunnel service request error.");const i="VsSaaS-Request-Id";return(null===(r=e.response)||void 0===r?void 0:r.headers)&&e.response.headers[i]&&(o+=`\nRequest ID: ${e.response.headers[i]}`),o}buildUri(e,t,n,s){let r=this.baseAddress;if(e){const t=new URL(r),n=parseInt(t.port,10);if("localhost"===t.hostname||t.hostname.startsWith(`${e}.`)){if("https:"===t.protocol&&e.startsWith("localhost")&&n%10>0){const s=parseInt(e.substring(9),10);s>0&&s<10&&(t.port=(n-n%10+s).toString(),r=t.toString())}}else t.hostname=`${e}.${t.hostname}`.replace("global.",""),r=t.toString()}r=`${r.replace(/\/$/,"")}${t}`;const o=this.tunnelRequestOptionsToQueryString(s,n);return o&&(r+=`?${o}`),r}buildUriForTunnel(e,t,n,s){let r="";if(e.clusterId&&e.tunnelId)r=`${c}/${e.tunnelId}`;else{if(!e.name)throw new Error("Tunnel object must include either a name or tunnel ID and cluster ID.");r=`${c}/${e.name}`}if(null==s?void 0:s.additionalQueryParameters)for(const[e,t]of Object.entries(s.additionalQueryParameters))n?n+=`&${e}=${t}`:n=`${e}=${t}`;return this.buildUri(e.clusterId,r+(t||""),n,s)}async getAxiosRequestConfig(e,t,n){const s={};if(t&&t.accessToken&&(o.TunnelAccessTokenProperties.validateTokenExpiration(t.accessToken),s[h]=`${r.TunnelAuthenticationSchemes.tunnel} ${t.accessToken}`),!(h in s)&&this.userTokenCallback){const e=await this.userTokenCallback();e&&(s[h]=e)}if(!(h in s)){const t=o.TunnelAccessTokenProperties.getTunnelAccessToken(e,n);t&&(s[h]=`${r.TunnelAuthenticationSchemes.tunnel} ${t}`)}const a=e=>{if(e)for(const[t,n]of Object.entries(e))s[t]=n};a(this.additionalRequestHeaders),a(null==t?void 0:t.additionalHeaders);const u=s["User-Agent"]?s["User-Agent"]+" ":"";s["User-Agent"]=`${u}${this.userAgents} ${i.tunnelSdkUserAgent}`;const c=Object.assign({headers:s},this.httpsAgent&&{httpsAgent:this.httpsAgent});return!1===(null==t?void 0:t.followRedirects)&&(c.maxRedirects=0),c}convertTunnelForRequest(e){var t;return{name:e.name,domain:e.domain,description:e.description,tags:e.tags,options:e.options,accessControl:e.accessControl?{entries:e.accessControl.entries.filter((e=>!e.isInherited))}:void 0,endpoints:e.endpoints,ports:null===(t=e.ports)||void 0===t?void 0:t.map((t=>this.convertTunnelPortForRequest(e,t)))}}convertTunnelPortForRequest(e,t){if(t.clusterId&&e.clusterId&&t.clusterId!==e.clusterId)throw new Error("Tunnel port cluster ID does not match tunnel.");if(t.tunnelId&&e.tunnelId&&t.tunnelId!==e.tunnelId)throw new Error("Tunnel port tunnel ID does not match tunnel.");return{portNumber:t.portNumber,protocol:t.protocol,isDefault:t.isDefault,description:t.description,tags:t.tags,sshUser:t.sshUser,options:t.options,accessControl:t.accessControl?{entries:t.accessControl.entries.filter((e=>!e.isInherited))}:void 0}}tunnelRequestOptionsToQueryString(e,t){const n={},r=[];e&&(e.includePorts&&(n.includePorts=["true"]),e.includeAccessControl&&(n.includeAccessControl=["true"]),e.tokenScopes&&(s.TunnelAccessControl.validateScopes(e.tokenScopes,void 0,!0),n.tokenScopes=e.tokenScopes),e.forceRename&&(n.forceRename=["true"]),e.tags&&(n.tags=e.tags,e.requireAllTags&&(n.allTags=["true"])),e.limit&&(n.limit=[e.limit.toString()]),r.push(...Object.keys(n).map((e=>`${e}=${n[e].map(encodeURIComponent).join(",")}`)))),t&&r.push(t);return r.join("&")}async request(e,t,n,s,r){this.trace(`${e} ${t}`),this.traceHeaders(s.headers),this.traceContent(n);const o=e=>{this.trace(`${e.status} ${e.statusText}`),this.traceHeaders(e.headers),this.traceContent(e.data)};try{s.url=t,s.method=e,s.data=n;const r=await a.default.request(s);return o(r),"DELETE"===e||r.data}catch(t){if(!(t instanceof Error&&t.isAxiosError))throw t;const n=t;if(n.response&&(o(n.response),r&&404===n.response.status))return"DELETE"!==e&&null;throw n.message=this.getResponseErrorMessage(n),delete n.request,n.response&&(delete n.config.httpAgent,delete n.config.httpsAgent,delete n.response.request),n}}traceHeaders(e){for(const[t,n]of Object.entries(e)){if("Authorization"===t)return void this.traceAuthorizationHeader(t,n);this.trace(`${t}: ${null!=n?n:""}`)}}traceAuthorizationHeader(e,t){if("string"!=typeof t)return;const n=t.indexOf(" ");if(n<0)return void this.trace(`${e}: [${t.length}]`);const s=t.substring(0,n),i=t.substring(n+1);if(s.toLowerCase()===r.TunnelAuthenticationSchemes.tunnel.toLowerCase()){const t=o.TunnelAccessTokenProperties.tryParse(i);if(t)return void this.trace(`${e}: ${s} <${t}>`)}this.trace(`${e}: ${s} <token>`)}traceContent(e){"object"==typeof e&&(e=JSON.stringify(e,void 0,"  ")),"string"==typeof e&&this.trace(y.replaceTokensInContent(e))}static replaceTokensInContent(e){var t;const n=/"(eyJ[a-zA-z0-9\-_]+\.[a-zA-z0-9\-_]+\.[a-zA-z0-9\-_]+)"/;let s=n.exec(e);for(;s;){let r=s[1];const i=o.TunnelAccessTokenProperties.tryParse(r);r=null!==(t=null==i?void 0:i.toString())&&void 0!==t?t:"token",e=e.substring(0,s.index+1)+"<"+r+">"+e.substring(s.index+s[0].length-1),s=n.exec(e)}return e}}t.TunnelManagementHttpClient=y},3797:(e,t,n)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.TunnelManagementHttpClient=void 0;const s=n(11536),r=n(32113),o=n(41380),i=n(41337),a=n(14206),u=n(25940),c="/api/v1",l=c+"/tunnels",d=c+"/userlimits",p="/endpoints",h="/ports",T=c+"/clusters",v="Authorization";function g(e,t){var n,s;return(null!==(n=e.portNumber)&&void 0!==n?n:Number.MAX_SAFE_INTEGER)-(null!==(s=t.portNumber)&&void 0!==s?s:Number.MAX_SAFE_INTEGER)}function f(e){return"string"==typeof e?new Date(Date.parse(e)):e}function m(e){e&&(e.created=f(e.created),e.status&&(e.status.lastHostConnectionTime=f(e.status.lastHostConnectionTime),e.status.lastClientConnectionTime=f(e.status.lastClientConnectionTime)))}function $(e){e&&e.status&&(e.status.lastClientConnectionTime=f(e.status.lastClientConnectionTime))}function w(e,t){var n;if(e.accessTokens&&t){null!==(n=t.accessTokens)&&void 0!==n||(t.accessTokens={});for(const n of Object.entries(e.accessTokens))t.accessTokens[n[0]]||(t.accessTokens[n[0]]=n[1])}}const A=[s.TunnelAccessScopes.Manage],y=[s.TunnelAccessScopes.Host],b=[s.TunnelAccessScopes.Manage,s.TunnelAccessScopes.ManagePorts,s.TunnelAccessScopes.Host],E=[s.TunnelAccessScopes.Manage,s.TunnelAccessScopes.ManagePorts,s.TunnelAccessScopes.Host,s.TunnelAccessScopes.Connect];class I{constructor(e,t,n,r,o){var i;if(this.httpsAgent=r,this.adapter=o,this.trace=e=>{},!e)throw new TypeError("User agent must be provided.");if(Array.isArray(e)){if(0===e.length)throw new TypeError("User agents cannot be empty.");let t="";e.forEach((e=>{var n;if("string"!=typeof e){if(!e.name)throw new TypeError("Invalid user agent. The name must be provided.");if("string"!=typeof e.name)throw new TypeError("Invalid user agent. The name must be a string.");if(e.version&&"string"!=typeof e.version)throw new TypeError("Invalid user agent. The version must be a string.");t=`${t}${e.name}/${null!==(n=e.version)&&void 0!==n?n:"unknown"} `}else t=`${t}${e} `})),this.userAgents=t.trim()}else if("string"!=typeof e){if(!e.name)throw new TypeError("Invalid user agent. The name must be provided.");if("string"!=typeof e.name)throw new TypeError("Invalid user agent. The name must be a string.");if(e.version&&"string"!=typeof e.version)throw new TypeError("Invalid user agent. The version must be a string.");this.userAgents=`${e.name}/${null!==(i=e.version)&&void 0!==i?i:"unknown"}`}else this.userAgents=e;this.userTokenCallback=null!=t?t:()=>Promise.resolve(null),n||(n=s.TunnelServiceProperties.production.serviceUri);const a=new URL(n);if(!a||"/"!==a.pathname)throw new TypeError(`Invalid tunnel service URI: ${n}`);this.baseAddress=n}async listTunnels(e,t,n){const s=[e?null:"global=true",t?`domain=${t}`:null].filter((e=>!!e)).join("&"),r=await this.sendRequest("GET",e,l,s,n);return r.forEach(m),r}async getTunnel(e,t){const n=await this.sendTunnelRequest("GET",e,E,void 0,void 0,t);return w(e,n),m(n),n}async createTunnel(e,t){if(e.tunnelId)throw new Error("An ID may not be specified when creating a tunnel.");e=this.convertTunnelForRequest(e);const n=await this.sendRequest("POST",e.clusterId,l,void 0,t,e);return w(e,n),m(n),n}async updateTunnel(e,t){const n=await this.sendTunnelRequest("PUT",e,A,void 0,void 0,t,this.convertTunnelForRequest(e));return w(e,n),m(n),n}async deleteTunnel(e,t){return await this.sendTunnelRequest("DELETE",e,A,void 0,void 0,t,void 0,!0)}async updateTunnelEndpoint(e,t,n){const s=`${p}/${t.hostId}/${t.connectionMode}`,r=await this.sendTunnelRequest("PUT",e,y,s,void 0,n,t);return e.endpoints&&(e.endpoints=e.endpoints.filter((e=>e.hostId!==t.hostId||e.connectionMode!==t.connectionMode)).concat(r)),r}async deleteTunnelEndpoints(e,t,n,s){const r=null==n?`${p}/${t}`:`${p}/${t}/${n}`,o=await this.sendTunnelRequest("DELETE",e,y,r,void 0,s,void 0,!0);return o&&e.endpoints&&(e.endpoints=e.endpoints.filter((e=>e.hostId!==t||e.connectionMode!==n))),o}async listUserLimits(){return await this.sendRequest("GET",void 0,d,void 0,void 0)||[]}async listTunnelPorts(e,t){const n=await this.sendTunnelRequest("GET",e,E,h,void 0,t);return n.forEach($),n}async getTunnelPort(e,t,n){const s=`${h}/${t}`,r=await this.sendTunnelRequest("GET",e,E,s,void 0,n);return $(r),r}async createTunnelPort(e,t,n){t=this.convertTunnelPortForRequest(e,t);const s=await this.sendTunnelRequest("POST",e,b,h,void 0,n,t);return e.ports&&(e.ports=e.ports.filter((e=>e.portNumber!==t.portNumber)).concat(s).sort(g)),$(s),s}async updateTunnelPort(e,t,n){if(t.clusterId&&e.clusterId&&t.clusterId!==e.clusterId)throw new Error("Tunnel port cluster ID is not consistent.");const s=t.portNumber,r=`${h}/${s}`;t=this.convertTunnelPortForRequest(e,t);const o=await this.sendTunnelRequest("PUT",e,b,r,void 0,n,t);return w(t,o),$(o),e.ports&&(e.ports=e.ports.filter((e=>e.portNumber!==t.portNumber)).concat(o).sort(g)),o}async deleteTunnelPort(e,t,n){const s=`${h}/${t}`,r=await this.sendTunnelRequest("DELETE",e,b,s,void 0,n,void 0,!0);return r&&e.ports&&(e.ports=e.ports.filter((e=>e.portNumber!==t)).sort(g)),r}async listClusters(){return await this.sendRequest("GET",void 0,T,void 0,void 0,void 0,!1)}async sendTunnelRequest(e,t,n,s,r,o,i,a){const u=await this.buildUriForTunnel(t,s,r,o),c=await this.getAxiosRequestConfig(t,o,n);return await this.request(e,u,i,c,a)}async sendRequest(e,t,n,s,r,o,i){const a=await this.buildUri(t,n,s,r),u=await this.getAxiosRequestConfig(void 0,r);return await this.request(e,a,o,u,i)}async checkNameAvailablility(e){e=encodeURI(e);const t=await this.buildUri(void 0,`${l}/${e}/checkAvailability`),n={httpsAgent:this.httpsAgent,adapter:this.adapter};return await this.request("GET",t,void 0,n)}getResponseErrorMessage(e){var t,n,s,r;let o="";if(null===(t=e.response)||void 0===t?void 0:t.data){const t=e.response.data;(t.title||t.detail)&&(o=`Tunnel service error: ${t.title}`,t.detail&&(o+=" "+t.detail),t.errors&&(o+=JSON.stringify(t.errors)))}o||(o=(null==e?void 0:e.response)?`Tunnel service returned status code: ${e.response.status} ${e.response.statusText}`:null!==(s=null!==(n=null==e?void 0:e.message)&&void 0!==n?n:e)&&void 0!==s?s:"Unknown tunnel service request error.");const i="VsSaaS-Request-Id";return(null===(r=e.response)||void 0===r?void 0:r.headers)&&e.response.headers[i]&&(o+=`\nRequest ID: ${e.response.headers[i]}`),o}async buildUri(e,t,n,s){if(void 0===e&&this.userTokenCallback){let t=await this.userTokenCallback();if(t&&t.startsWith("tunnelplan")){t=t.replace("tunnelplan ","");const n=u.TunnelPlanTokenProperties.tryParse(t);null!==n&&n.clusterId&&(e=n.clusterId)}}let r=this.baseAddress;if(e){const t=new URL(r),n=parseInt(t.port,10);if("localhost"===t.hostname||t.hostname.startsWith(`${e}.`)){if("https:"===t.protocol&&e.startsWith("localhost")&&n%10>0){const s=parseInt(e.substring(9),10);s>0&&s<10&&(t.port=(n-n%10+s).toString(),r=t.toString())}}else t.hostname=`${e}.${t.hostname}`.replace("global.",""),r=t.toString()}r=`${r.replace(/\/$/,"")}${t}`;const o=this.tunnelRequestOptionsToQueryString(s,n);return o&&(r+=`?${o}`),r}buildUriForTunnel(e,t,n,s){let r="";if(e.clusterId&&e.tunnelId)r=`${l}/${e.tunnelId}`;else{if(!e.name)throw new Error("Tunnel object must include either a name or tunnel ID and cluster ID.");r=`${l}/${e.name}`}if(null==s?void 0:s.additionalQueryParameters)for(const[e,t]of Object.entries(s.additionalQueryParameters))n?n+=`&${e}=${t}`:n=`${e}=${t}`;return this.buildUri(e.clusterId,r+(t||""),n,s)}async getAxiosRequestConfig(e,t,n){const s={};if(t&&t.accessToken&&(o.TunnelAccessTokenProperties.validateTokenExpiration(t.accessToken),s[v]=`${r.TunnelAuthenticationSchemes.tunnel} ${t.accessToken}`),!(v in s)&&this.userTokenCallback){const e=await this.userTokenCallback();e&&(s[v]=e)}if(!(v in s)){const t=o.TunnelAccessTokenProperties.getTunnelAccessToken(e,n);t&&(s[v]=`${r.TunnelAuthenticationSchemes.tunnel} ${t}`)}const a=e=>{if(e)for(const[t,n]of Object.entries(e))s[t]=n};a(this.additionalRequestHeaders),a(null==t?void 0:t.additionalHeaders);const u=s["User-Agent"]?s["User-Agent"]+" ":"";s["User-Agent"]=`${u}${this.userAgents} ${i.tunnelSdkUserAgent}`;const c=Object.assign(Object.assign({headers:s},this.httpsAgent&&{httpsAgent:this.httpsAgent}),this.adapter&&{adapter:this.adapter});return!1===(null==t?void 0:t.followRedirects)&&(c.maxRedirects=0),c}convertTunnelForRequest(e){var t;return{name:e.name,domain:e.domain,description:e.description,tags:e.tags,options:e.options,accessControl:e.accessControl?{entries:e.accessControl.entries.filter((e=>!e.isInherited))}:void 0,endpoints:e.endpoints,ports:null===(t=e.ports)||void 0===t?void 0:t.map((t=>this.convertTunnelPortForRequest(e,t)))}}convertTunnelPortForRequest(e,t){if(t.clusterId&&e.clusterId&&t.clusterId!==e.clusterId)throw new Error("Tunnel port cluster ID does not match tunnel.");if(t.tunnelId&&e.tunnelId&&t.tunnelId!==e.tunnelId)throw new Error("Tunnel port tunnel ID does not match tunnel.");return{portNumber:t.portNumber,protocol:t.protocol,isDefault:t.isDefault,description:t.description,tags:t.tags,sshUser:t.sshUser,options:t.options,accessControl:t.accessControl?{entries:t.accessControl.entries.filter((e=>!e.isInherited))}:void 0}}tunnelRequestOptionsToQueryString(e,t){const n={},r=[];e&&(e.includePorts&&(n.includePorts=["true"]),e.includeAccessControl&&(n.includeAccessControl=["true"]),e.tokenScopes&&(s.TunnelAccessControl.validateScopes(e.tokenScopes,void 0,!0),n.tokenScopes=e.tokenScopes),e.forceRename&&(n.forceRename=["true"]),e.tags&&(n.tags=e.tags,e.requireAllTags&&(n.allTags=["true"])),e.limit&&(n.limit=[e.limit.toString()]),r.push(...Object.keys(n).map((e=>`${e}=${n[e].map(encodeURIComponent).join(",")}`)))),t&&r.push(t);return r.join("&")}async request(e,t,n,s,r){this.trace(`${e} ${t}`),this.traceHeaders(s.headers),this.traceContent(n);const o=e=>{this.trace(`${e.status} ${e.statusText}`),this.traceHeaders(e.headers),this.traceContent(e.data)};try{s.url=t,s.method=e,s.data=n;const r=await a.default.request(s);return o(r),"DELETE"===e||r.data}catch(t){if(!(t instanceof Error&&t.isAxiosError))throw t;const n=t;if(n.response&&(o(n.response),r&&404===n.response.status))return"DELETE"!==e&&null;throw n.message=this.getResponseErrorMessage(n),delete n.request,n.response&&(delete n.config.httpAgent,delete n.config.httpsAgent,delete n.response.request),n}}traceHeaders(e){for(const[t,n]of Object.entries(e)){if("Authorization"===t)return void this.traceAuthorizationHeader(t,n);this.trace(`${t}: ${null!=n?n:""}`)}}traceAuthorizationHeader(e,t){if("string"!=typeof t)return;const n=t.indexOf(" ");if(n<0)return void this.trace(`${e}: [${t.length}]`);const s=t.substring(0,n),i=t.substring(n+1);if(s.toLowerCase()===r.TunnelAuthenticationSchemes.tunnel.toLowerCase()){const t=o.TunnelAccessTokenProperties.tryParse(i);if(t)return void this.trace(`${e}: ${s} <${t}>`)}this.trace(`${e}: ${s} <token>`)}traceContent(e){"object"==typeof e&&(e=JSON.stringify(e,void 0,"  ")),"string"==typeof e&&this.trace(I.replaceTokensInContent(e))}static replaceTokensInContent(e){var t;const n=/"(eyJ[a-zA-z0-9\-_]+\.[a-zA-z0-9\-_]+\.[a-zA-z0-9\-_]+)"/;let s=n.exec(e);for(;s;){let r=s[1];const i=o.TunnelAccessTokenProperties.tryParse(r);r=null!==(t=null==i?void 0:i.toString())&&void 0!==t?t:"token",e=e.substring(0,s.index+1)+"<"+r+">"+e.substring(s.index+s[0].length-1),s=n.exec(e)}return e}}t.TunnelManagementHttpClient=I}}]);