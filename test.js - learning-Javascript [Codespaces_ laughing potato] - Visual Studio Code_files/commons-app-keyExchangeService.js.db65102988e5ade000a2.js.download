"use strict";(self.webpackChunkcodespaces_web_client=self.webpackChunkcodespaces_web_client||[]).push([[353],{948:function(e,t,i){var n,s=this&&this.__decorate||function(e,t,i,n){var s,o=arguments.length,r=o<3?t:null===n?n=Object.getOwnPropertyDescriptor(t,i):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)r=Reflect.decorate(e,t,i,n);else for(var a=e.length-1;a>=0;a--)(s=e[a])&&(r=(o<3?s(r):o>3?s(t,i,r):s(t,i))||r);return o>3&&r&&Object.defineProperty(t,i,r),r};Object.defineProperty(t,"__esModule",{value:!0}),t.KeyExchangeService=void 0;const o=i(30816),r=i(25802),a=i(14293),h=i(65832),c=i(56485),l=i(36186),g=i(3364),x=i(77316),m=i(81978),y=i(96434),u=i(83730),d=i(52826),f=i(28499),v=i(70158);class C{}const p="ext-info-s",w="ext-info-c";let E=n=class extends a.SshService{constructor(e){super(e),this.isInitialExchange=!1,this.exchangeContext=null}get exchanging(){return!!this.exchangeContext}async startKeyExchange(e){this.isInitialExchange=e,this.exchangeContext=new C;const t=this.createKeyExchangeInitMessage();let i=null;return this.session.isClientSession?(e&&this.session.config.enableKeyExchangeGuess&&(i=await this.createKeyExchangeGuessMessage(),t.firstKexPacketFollows=!!i),this.exchangeContext.clientKexInitPayload=t.toBuffer()):this.exchangeContext.serverKexInitPayload=t.toBuffer(),[t,i]}finishKeyExchange(){var e;if(!this.exchangeContext)throw new x.SshConnectionError("Key exchange not started.",m.SshDisconnectReason.protocolError);const t=this.exchangeContext.newAlgorithms;if(!t)throw new x.SshConnectionError("Key exchange not completed.",m.SshDisconnectReason.protocolError);return t.isExtensionInfoRequested=null===(e=this.exchangeContext)||void 0===e?void 0:e.isExtensionInfoRequested,this.exchangeContext=null,t}abortKeyExchange(){this.exchangeContext=null}createKeyExchangeInitMessage(){const e=this.session.isClientSession?w:p,t=this.session.config,i=new c.KeyExchangeInitMessage;return i.keyExchangeAlgorithms=(0,l.algorithmNames)(t.keyExchangeAlgorithms).concat(e),i.serverHostKeyAlgorithms=this.getPublicKeyAlgorithms(),i.encryptionAlgorithmsClientToServer=i.encryptionAlgorithmsServerToClient=(0,l.algorithmNames)(t.encryptionAlgorithms),i.macAlgorithmsClientToServer=i.macAlgorithmsServerToClient=(0,l.algorithmNames)(t.hmacAlgorithms),i.compressionAlgorithmsClientToServer=i.compressionAlgorithmsServerToClient=(0,l.algorithmNames)(t.compressionAlgorithms),i.languagesClientToServer=[""],i.languagesServerToClient=[""],i.firstKexPacketFollows=!1,i.reserved=0,i}getPublicKeyAlgorithms(){var e,t;let i=[...this.session.config.publicKeyAlgorithms];if(i.length>1&&!this.session.isClientSession){const n=null===(t=null===(e=this.session.credentials)||void 0===e?void 0:e.publicKeys)||void 0===t?void 0:t.map((e=>e.keyAlgorithmName));n&&(i=i.filter((e=>e&&n.includes(e.keyAlgorithmName))))}return(0,l.algorithmNames)(i)}async createKeyExchangeGuessMessage(){if(!this.exchangeContext)throw new Error("Key exchange was not started.");const e=this.session.config.keyExchangeAlgorithms[0];if(!e)return null;this.exchangeContext.keyExchange=e.name,this.exchangeContext.exchange=e.createKeyExchange(),this.exchangeContext.exchangeValue=await this.exchangeContext.exchange.startKeyExchange();const t=new c.KeyExchangeDhInitMessage;return t.e=this.exchangeContext.exchangeValue,t}handleMessage(e,t){if(e instanceof c.KeyExchangeInitMessage)return this.handleInitMessage(e,t);if(e instanceof c.KeyExchangeDhInitMessage)return this.handleDhInitMessage(e,t);if(e instanceof c.KeyExchangeDhReplyMessage)return this.handleDhReplyMessage(e,t);throw new Error(`Message not implemented: ${e}`)}async handleInitMessage(e,t){var i,n,s,o;if(!this.exchangeContext)throw new Error("Key exchange was not started.");const r=this.session.config;if(this.exchangeContext.keyExchange=this.chooseAlgorithm("KeyExchange",(0,l.algorithmNames)(r.keyExchangeAlgorithms),e.keyExchangeAlgorithms),"none"===this.exchangeContext.keyExchange)return this.trace(v.TraceLevel.Info,v.SshTraceEventIds.algorithmNegotiation,"Client and server negotiated no security. Cancelling key-exchange."),this.session.activateService(d.ConnectionService),this.exchangeContext.newAlgorithms=new y.SshSessionAlgorithms,void await this.session.handleNewKeysMessage(new c.NewKeysMessage,t);if(this.exchangeContext.publicKey=this.chooseAlgorithm("PublicKey",this.getPublicKeyAlgorithms(),e.serverHostKeyAlgorithms),this.exchangeContext.clientEncryption=this.chooseAlgorithm("ClientEncryption",(0,l.algorithmNames)(r.encryptionAlgorithms),e.encryptionAlgorithmsClientToServer),this.exchangeContext.serverEncryption=this.chooseAlgorithm("ServerEncryption",(0,l.algorithmNames)(r.encryptionAlgorithms),e.encryptionAlgorithmsServerToClient),this.exchangeContext.clientHmac=this.chooseAlgorithm("ClientHmac",(0,l.algorithmNames)(r.hmacAlgorithms),e.macAlgorithmsClientToServer),this.exchangeContext.serverHmac=this.chooseAlgorithm("ServerHmac",(0,l.algorithmNames)(r.hmacAlgorithms),e.macAlgorithmsServerToClient),this.exchangeContext.clientCompression=this.chooseAlgorithm("ClientCompression",(0,l.algorithmNames)(r.compressionAlgorithms),e.compressionAlgorithmsClientToServer),this.exchangeContext.serverCompression=this.chooseAlgorithm("ServerCompression",(0,l.algorithmNames)(r.compressionAlgorithms),e.compressionAlgorithmsServerToClient),this.session.isClientSession){this.exchangeContext.serverKexInitPayload=e.toBuffer();const s=!!this.exchangeContext.exchangeValue,o=this.exchangeContext.keyExchange===(null===(i=r.keyExchangeAlgorithms[0])||void 0===i?void 0:i.name);if(s&&o)this.trace(v.TraceLevel.Verbose,v.SshTraceEventIds.algorithmNegotiation,"Already sent correct guess for key-exchange init.");else{const e=r.getKeyExchangeAlgorithm(this.exchangeContext.keyExchange);this.exchangeContext.exchange=e.createKeyExchange(),this.exchangeContext.exchangeValue=await this.exchangeContext.exchange.startKeyExchange();const i=new c.KeyExchangeDhInitMessage;i.e=this.exchangeContext.exchangeValue,await this.session.sendMessage(i,t)}this.exchangeContext.isExtensionInfoRequested=this.isInitialExchange&&(null===(n=e.keyExchangeAlgorithms)||void 0===n?void 0:n.includes(p))}else{if(e.firstKexPacketFollows){const t=this.exchangeContext.keyExchange===(null===(s=e.keyExchangeAlgorithms)||void 0===s?void 0:s[0]),i=t?"correct":"incorrect";this.trace(v.TraceLevel.Verbose,v.SshTraceEventIds.algorithmNegotiation,`Client's KeyExchange guess was ${i}.`),this.exchangeContext.discardGuessedInit=!t}this.exchangeContext.clientKexInitPayload=e.toBuffer(),this.exchangeContext.isExtensionInfoRequested=this.isInitialExchange&&(null===(o=e.keyExchangeAlgorithms)||void 0===o?void 0:o.includes(w))}}async handleDhInitMessage(e,t){var i,n,s,r,a;if(this.session.isClientSession)return;const h=this.session;if(!this.exchangeContext||!this.exchangeContext.keyExchange||!this.exchangeContext.publicKey)throw new x.SshConnectionError("Key exchange not started.",m.SshDisconnectReason.protocolError);if(this.exchangeContext.discardGuessedInit)return void(this.exchangeContext.discardGuessedInit=!1);const l=this.session.config.getKeyExchangeAlgorithm(this.exchangeContext.keyExchange);if(!l)throw new x.SshConnectionError("Key exchange not supported for algorithm: "+this.exchangeContext.keyExchange,m.SshDisconnectReason.keyExchangeFailed);const g=this.session.config.getPublicKeyAlgorithm(this.exchangeContext.publicKey);if(!g)throw new x.SshConnectionError("Public key algorithm not supported: "+this.exchangeContext.publicKey,m.SshDisconnectReason.keyExchangeFailed);let d=null;if(null===(i=h.credentials)||void 0===i?void 0:i.publicKeys){const e=h.credentials.publicKeys.find((e=>e.keyAlgorithmName===g.keyAlgorithmName));if(d=null!=e?e:null,!1===(null==d?void 0:d.hasPrivateKey)){if(!h.credentials.privateKeyProvider)throw new Error("A private key provider is required.");d=await h.credentials.privateKeyProvider(e,null!=t?t:u.CancellationToken.None)}}if(null==d)throw new x.SshConnectionError("Private key not found for algorithm: "+this.exchangeContext.publicKey,m.SshDisconnectReason.keyExchangeFailed);const f=this.session.config.getEncryptionAlgorithm(this.exchangeContext.clientEncryption),v=this.session.config.getEncryptionAlgorithm(this.exchangeContext.serverEncryption),C=this.session.config.getHmacAlgorithm(this.exchangeContext.serverHmac),p=this.session.config.getHmacAlgorithm(this.exchangeContext.clientHmac),w=l.createKeyExchange(),E=e.e||o.Buffer.alloc(0),K=await w.startKeyExchange(),S=await w.decryptKeyExchange(E),A=await d.getPublicKeyBytes(g.name);if(!A)throw new x.SshConnectionError("Public key not set.",m.SshDisconnectReason.keyExchangeFailed);const k=await this.computeExchangeHash(w,A,E,K,S);this.session.sessionId||(this.session.sessionId=k);const[I,b,N,M,T,B]=await this.computeKeys(w,S,k,f,v,p,C),P=null!==(n=await(null==v?void 0:v.createCipher(!0,M,b)))&&void 0!==n?n:null,D=null!==(s=await(null==f?void 0:f.createCipher(!1,N,I)))&&void 0!==s?s:null,V=null!==(r=await(null==C?void 0:C.createSigner(B)))&&void 0!==r?r:null,R=null!==(a=await(null==p?void 0:p.createVerifier(T)))&&void 0!==a?a:null,H=new y.SshSessionAlgorithms;H.publicKeyAlgorithmName=this.exchangeContext.publicKey,H.cipher=P,H.decipher=D,H.signer=V,H.verifier=R,H.messageSigner=(null==P?void 0:P.authenticatedEncryption)?P:V,H.messageVerifier=(null==D?void 0:D.authenticatedEncryption)?D:R,H.compressor=this.session.config.getCompressionAlgorithm(this.exchangeContext.serverCompression),H.decompressor=this.session.config.getCompressionAlgorithm(this.exchangeContext.clientCompression),this.exchangeContext.newAlgorithms=H,I&&I.fill(0),N&&N.fill(0),T&&T.fill(0),b&&b.fill(0),M&&M.fill(0),B&&B.fill(0);const L=g.createSigner(d);let F=await L.sign(k);F=g.createSignatureData(F);const $=new c.KeyExchangeDhReplyMessage;$.hostKey=A,$.f=K,$.signature=F,await this.session.sendMessage($,t),await this.session.sendMessage(new c.NewKeysMessage,t)}async handleDhReplyMessage(e,t){var i,n,s,o;if(!this.session.isClientSession)return;if(!this.exchangeContext)throw new x.SshConnectionError("Key exchange was not started.",m.SshDisconnectReason.protocolError);const r=this.session.config,a=this.exchangeContext.exchange,h=this.exchangeContext.publicKey,l=r.getPublicKeyAlgorithm(h),g=r.getEncryptionAlgorithm(this.exchangeContext.clientEncryption),u=r.getEncryptionAlgorithm(this.exchangeContext.serverEncryption),d=r.getHmacAlgorithm(this.exchangeContext.serverHmac),f=r.getHmacAlgorithm(this.exchangeContext.clientHmac),C=this.exchangeContext.exchangeValue,p=e.f;if(!a||!C)throw new x.SshConnectionError("Failed to initialize crypto after key exchange.",m.SshDisconnectReason.keyExchangeFailed);this.hostKey=l.createKeyPair(),await this.hostKey.setPublicKeyBytes(e.hostKey);const w=await a.decryptKeyExchange(p),E=e.hostKey,K=await this.computeExchangeHash(a,E,C,p,w),S=l.readSignatureData(e.signature),A=l.createVerifier(this.hostKey);let k;try{k=await A.verify(K,S)}catch(e){if(!(e instanceof Error))throw e;throw this.trace(v.TraceLevel.Error,v.SshTraceEventIds.serverAuthenticationFailed,`Server public key verification error: ${e.message}`,e),new x.SshConnectionError(`Server public key verification failed: ${e.message}`,m.SshDisconnectReason.hostKeyNotVerifiable)}if(!k)throw this.trace(v.TraceLevel.Warning,v.SshTraceEventIds.serverAuthenticationFailed,"Server public key verification failed."),new x.SshConnectionError("Server public key verification failed.",m.SshDisconnectReason.hostKeyNotVerifiable);this.trace(v.TraceLevel.Verbose,v.SshTraceEventIds.sessionAuthenticated,"Server public key verification succeeded."),null==this.session.sessionId&&(this.session.sessionId=K);const[I,b,N,M,T,B]=await this.computeKeys(a,w,K,g,u,f,d),P=null!==(i=await(null==g?void 0:g.createCipher(!0,N,I)))&&void 0!==i?i:null,D=null!==(n=await(null==u?void 0:u.createCipher(!1,M,b)))&&void 0!==n?n:null,V=null!==(s=await(null==f?void 0:f.createSigner(T)))&&void 0!==s?s:null,R=null!==(o=await(null==d?void 0:d.createVerifier(B)))&&void 0!==o?o:null,H=new y.SshSessionAlgorithms;H.publicKeyAlgorithmName=h,H.cipher=P,H.decipher=D,H.signer=V,H.verifier=R,H.messageSigner=(null==P?void 0:P.authenticatedEncryption)?P:V,H.messageVerifier=(null==D?void 0:D.authenticatedEncryption)?D:R,H.compressor=r.getCompressionAlgorithm(this.exchangeContext.clientCompression),H.decompressor=r.getCompressionAlgorithm(this.exchangeContext.serverCompression),this.exchangeContext.newAlgorithms=H,I&&I.fill(0),N&&N.fill(0),T&&T.fill(0),b&&b.fill(0),M&&M.fill(0),B&&B.fill(0),await this.session.sendMessage(new c.NewKeysMessage,t)}chooseAlgorithm(e,t,i){let n,s;this.session.isClientSession?(n=i||[],s=t):(n=t,s=i||[]);const o=`${e} negotiation: Server (${n.join(", ")}) Client (${s.join(", ")})`;for(const e of s)for(const t of n)if(t===e){const e=t;return this.trace(v.TraceLevel.Info,v.SshTraceEventIds.algorithmNegotiation,`${o} => ${e}`),e}throw new Error(`Failed ${o}`)}async computeExchangeHash(e,t,i,n,s){if(!this.session.remoteVersion)throw new Error("Key exchange not completed.");const a=new g.SshDataWriter(o.Buffer.alloc(2048));this.session.isClientSession?(a.writeString(r.SshSession.localVersion.toString(),"ascii"),a.writeString(this.session.remoteVersion.toString(),"ascii")):(a.writeString(this.session.remoteVersion.toString(),"ascii"),a.writeString(r.SshSession.localVersion.toString(),"ascii")),a.writeBinary(this.exchangeContext.clientKexInitPayload),a.writeBinary(this.exchangeContext.serverKexInitPayload),a.writeBinary(t),a.writeBigInt(h.BigInt.fromBytes(i,{unsigned:!0})),a.writeBigInt(h.BigInt.fromBytes(n,{unsigned:!0})),a.writeBigInt(h.BigInt.fromBytes(s,{unsigned:!0}));return await e.sign(a.toBuffer())}async computeKeys(e,t,i,n,s,r,a){var h,c;const l=new g.SshDataWriter(o.Buffer.alloc(4+t.length+i.length+Math.max(1+(null!==(c=null===(h=this.session.sessionId)||void 0===h?void 0:h.length)&&void 0!==c?c:0),e.digestLength)));l.writeBinary(t),l.write(i);const x=l.position;return[n&&await this.computeKey(e,l,x,n.blockLength,"A"),s&&await this.computeKey(e,l,x,s.blockLength,"B"),n&&await this.computeKey(e,l,x,n.keyLength,"C"),s&&await this.computeKey(e,l,x,s.keyLength,"D"),r&&await this.computeKey(e,l,x,r.keyLength,"E"),a&&await this.computeKey(e,l,x,a.keyLength,"F")]}async computeKey(e,t,i,n,s){const r=o.Buffer.alloc(n);let a=0,h=0,c=null;if(!this.session.sessionId)throw new Error("Session ID not set.");for(;a<n;)t.position=i,c?t.write(c):(t.writeByte(s.charCodeAt(0)),t.write(this.session.sessionId)),c=await e.sign(t.toBuffer()),h=Math.min(c.length,n-a),c.copy(r,a),a+=h;return c&&c.fill(0),r}};E.serviceName="ssh-keyexchange",E=n=s([(0,f.serviceActivation)({serviceRequest:n.serviceName})],E),t.KeyExchangeService=E},43210:function(e,t,i){var n,s=this&&this.__decorate||function(e,t,i,n){var s,o=arguments.length,r=o<3?t:null===n?n=Object.getOwnPropertyDescriptor(t,i):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)r=Reflect.decorate(e,t,i,n);else for(var a=e.length-1;a>=0;a--)(s=e[a])&&(r=(o<3?s(r):o>3?s(t,i,r):s(t,i))||r);return o>3&&r&&Object.defineProperty(t,i,r),r};Object.defineProperty(t,"__esModule",{value:!0}),t.KeyExchangeService=void 0;const o=i(30816),r=i(7395),a=i(90447),h=i(30404),c=i(50856),l=i(91605),g=i(67914),x=i(72917),m=i(90818),y=i(47462),u=i(83730),d=i(34670),f=i(43776);class v{}const C="ext-info-s",p="ext-info-c";let w=n=class extends a.SshService{constructor(e,t){super(e),this.isClientSession=t,this.isInitialExchange=!1,this.exchangeContext=null}get exchanging(){return!!this.exchangeContext}async startKeyExchange(e){this.isInitialExchange=e,this.exchangeContext=new v;const t=this.createKeyExchangeInitMessage();let i=null;return this.isClientSession?(e&&this.session.config.enableKeyExchangeGuess&&(i=await this.createKeyExchangeGuessMessage(),t.firstKexPacketFollows=!!i),this.exchangeContext.clientKexInitPayload=t.toBuffer()):this.exchangeContext.serverKexInitPayload=t.toBuffer(),[t,i]}finishKeyExchange(){const e=this.exchangeContext.newAlgorithms;return this.exchangeContext=null,e}abortKeyExchange(){this.exchangeContext=null}createKeyExchangeInitMessage(){const e=this.isClientSession?p:C,t=this.session.config,i=new c.KeyExchangeInitMessage;return i.keyExchangeAlgorithms=(0,l.algorithmNames)(t.keyExchangeAlgorithms).concat(e),i.serverHostKeyAlgorithms=this.getPublicKeyAlgorithms(),i.encryptionAlgorithmsClientToServer=i.encryptionAlgorithmsServerToClient=(0,l.algorithmNames)(t.encryptionAlgorithms),i.macAlgorithmsClientToServer=i.macAlgorithmsServerToClient=(0,l.algorithmNames)(t.hmacAlgorithms),i.compressionAlgorithmsClientToServer=i.compressionAlgorithmsServerToClient=(0,l.algorithmNames)(t.compressionAlgorithms),i.languagesClientToServer=[""],i.languagesServerToClient=[""],i.firstKexPacketFollows=!1,i.reserved=0,i}getPublicKeyAlgorithms(){var e,t;let i=[...this.session.config.publicKeyAlgorithms];if(i.length>1&&!this.isClientSession){const n=null===(t=null===(e=this.session.credentials)||void 0===e?void 0:e.publicKeys)||void 0===t?void 0:t.map((e=>e.keyAlgorithmName));n&&(i=i.filter((e=>e&&n.includes(e.keyAlgorithmName))))}return(0,l.algorithmNames)(i)}async createKeyExchangeGuessMessage(){if(!this.exchangeContext)throw new Error("Key exchange was not started.");const e=this.session.config.keyExchangeAlgorithms[0];if(!e)return null;this.exchangeContext.keyExchange=e.name,this.exchangeContext.exchange=e.createKeyExchange(),this.exchangeContext.exchangeValue=await this.exchangeContext.exchange.startKeyExchange();const t=new c.KeyExchangeDhInitMessage;return t.e=this.exchangeContext.exchangeValue,t}handleMessage(e,t){if(e instanceof c.KeyExchangeInitMessage)return this.handleInitMessage(e,t);if(e instanceof c.KeyExchangeDhInitMessage)return this.handleDhInitMessage(e,t);if(e instanceof c.KeyExchangeDhReplyMessage)return this.handleDhReplyMessage(e,t);throw new Error(`Message not implemented: ${e}`)}async handleInitMessage(e,t){var i,n,s,o,r;if(!this.exchangeContext)throw new Error("Key exchange was not started.");const a=this.session.config;if(this.exchangeContext.keyExchange=this.chooseAlgorithm("KeyExchange",(0,l.algorithmNames)(a.keyExchangeAlgorithms),e.keyExchangeAlgorithms),"none"===this.exchangeContext.keyExchange)return this.trace(f.TraceLevel.Info,f.SshTraceEventIds.algorithmNegotiation,"Client and server negotiated no security. Cancelling key-exchange."),this.exchangeContext.newAlgorithms=new y.SshSessionAlgorithms,void await this.session.handleNewKeysMessage(new c.NewKeysMessage,t);let h;if(this.exchangeContext.publicKey=this.chooseAlgorithm("PublicKey",this.getPublicKeyAlgorithms(),e.serverHostKeyAlgorithms),this.exchangeContext.clientEncryption=this.chooseAlgorithm("ClientEncryption",(0,l.algorithmNames)(a.encryptionAlgorithms),e.encryptionAlgorithmsClientToServer),this.exchangeContext.serverEncryption=this.chooseAlgorithm("ServerEncryption",(0,l.algorithmNames)(a.encryptionAlgorithms),e.encryptionAlgorithmsServerToClient),this.exchangeContext.clientHmac=this.chooseAlgorithm("ClientHmac",(0,l.algorithmNames)(a.hmacAlgorithms),e.macAlgorithmsClientToServer),this.exchangeContext.serverHmac=this.chooseAlgorithm("ServerHmac",(0,l.algorithmNames)(a.hmacAlgorithms),e.macAlgorithmsServerToClient),this.exchangeContext.clientCompression=this.chooseAlgorithm("ClientCompression",(0,l.algorithmNames)(a.compressionAlgorithms),e.compressionAlgorithmsClientToServer),this.exchangeContext.serverCompression=this.chooseAlgorithm("ServerCompression",(0,l.algorithmNames)(a.compressionAlgorithms),e.compressionAlgorithmsServerToClient),this.isClientSession){this.exchangeContext.serverKexInitPayload=e.toBuffer();const n=!!this.exchangeContext.exchangeValue,s=this.exchangeContext.keyExchange===(null===(i=a.keyExchangeAlgorithms[0])||void 0===i?void 0:i.name);if(!n||!s){const e=a.getKeyExchangeAlgorithm(this.exchangeContext.keyExchange);this.exchangeContext.exchange=e.createKeyExchange(),this.exchangeContext.exchangeValue=await this.exchangeContext.exchange.startKeyExchange();const i=new c.KeyExchangeDhInitMessage;i.e=this.exchangeContext.exchangeValue,await this.session.sendMessage(i,t)}h=C}else{if(e.firstKexPacketFollows){const t=this.exchangeContext.keyExchange===(null===(n=e.keyExchangeAlgorithms)||void 0===n?void 0:n[0]),i=t?"correct":"incorrect";if(this.trace(f.TraceLevel.Verbose,f.SshTraceEventIds.algorithmNegotiation,`Client's KeyExchange guess was ${i}.`),this.exchangeContext.discardGuessedInit=!t,t&&this.session.remoteVersion.isVsSsh&&(null===(s=this.session.remoteVersion.version)||void 0===s?void 0:s.startsWith("2."))){(null===(o=e.keyExchangeAlgorithms)||void 0===o?void 0:o[0])===(null===(r=a.keyExchangeAlgorithms[0])||void 0===r?void 0:r.name)||(this.trace(f.TraceLevel.Verbose,f.SshTraceEventIds.algorithmNegotiation,"Ignoring correct guess for compatibility with older client."),this.exchangeContext.discardGuessedInit=!0)}}this.exchangeContext.clientKexInitPayload=e.toBuffer(),h=p}this.isInitialExchange&&e.keyExchangeAlgorithms.includes(h)&&await this.session.sendExtensionInfo(t)}async handleDhInitMessage(e,t){var i,n,s,r,a,h,l;if(this.isClientSession)return;const g=this.session;if(!this.exchangeContext||!this.exchangeContext.keyExchange||!this.exchangeContext.publicKey)throw new x.SshConnectionError("Key exchange not started.",m.SshDisconnectReason.protocolError);if(this.exchangeContext.discardGuessedInit)return void(this.exchangeContext.discardGuessedInit=!1);const d=this.session.config.getKeyExchangeAlgorithm(this.exchangeContext.keyExchange);if(!d)throw new x.SshConnectionError("Key exchange not supported for algorithm: "+this.exchangeContext.keyExchange,m.SshDisconnectReason.keyExchangeFailed);const f=this.session.config.getPublicKeyAlgorithm(this.exchangeContext.publicKey);if(!f)throw new x.SshConnectionError("Public key algorithm not supported: "+this.exchangeContext.publicKey,m.SshDisconnectReason.keyExchangeFailed);let v=null;if(null===(i=g.credentials)||void 0===i?void 0:i.publicKeys){const e=g.credentials.publicKeys.find((e=>e.keyAlgorithmName===f.keyAlgorithmName));if(v=null!=e?e:null,!1===(null==v?void 0:v.hasPrivateKey)){if(!g.credentials.privateKeyProvider)throw new Error("A private key provider is required.");v=await g.credentials.privateKeyProvider(e,null!=t?t:u.CancellationToken.None)}}if(null==v)throw new x.SshConnectionError("Private key not found for algorithm: "+this.exchangeContext.publicKey,m.SshDisconnectReason.keyExchangeFailed);const C=this.session.config.getEncryptionAlgorithm(this.exchangeContext.clientEncryption),p=this.session.config.getEncryptionAlgorithm(this.exchangeContext.serverEncryption),w=this.session.config.getHmacAlgorithm(this.exchangeContext.serverHmac),E=this.session.config.getHmacAlgorithm(this.exchangeContext.clientHmac),K=d.createKeyExchange(),S=e.e||o.Buffer.alloc(0),A=await K.startKeyExchange(),k=await K.decryptKeyExchange(S),I=await v.getPublicKeyBytes(f.name);if(!I)throw new x.SshConnectionError("Public key not set.",m.SshDisconnectReason.keyExchangeFailed);const b=await this.computeExchangeHash(K,I,S,A,k);this.session.sessionId||(this.session.sessionId=b);const[N,M,T,B,P,D]=await this.computeKeys(K,k,b,C,p,E,w),V=null!==(n=await(null==p?void 0:p.createCipher(!0,B,M)))&&void 0!==n?n:null,R=null!==(s=await(null==C?void 0:C.createCipher(!1,T,N)))&&void 0!==s?s:null,H=null!==(r=await(null==w?void 0:w.createSigner(D)))&&void 0!==r?r:null,L=null!==(a=await(null==E?void 0:E.createVerifier(P)))&&void 0!==a?a:null,F=new y.SshSessionAlgorithms;F.publicKeyAlgorithmName=this.exchangeContext.publicKey,F.cipher=V,F.decipher=R,F.signer=H,F.verifier=L,F.messageSigner=(null===(h=V)||void 0===h?void 0:h.authenticatedEncryption)?V:H,F.messageVerifier=(null===(l=R)||void 0===l?void 0:l.authenticatedEncryption)?R:L,F.compressor=this.session.config.getCompressionAlgorithm(this.exchangeContext.serverCompression),F.decompressor=this.session.config.getCompressionAlgorithm(this.exchangeContext.clientCompression),this.exchangeContext.newAlgorithms=F,N&&N.fill(0),T&&T.fill(0),P&&P.fill(0),M&&M.fill(0),B&&B.fill(0),D&&D.fill(0);const $=f.createSigner(v);let G=await $.sign(b);G=f.createSignatureData(G);const j=new c.KeyExchangeDhReplyMessage;j.hostKey=I,j.f=A,j.signature=G,await this.session.sendMessage(j,t),await this.session.sendMessage(new c.NewKeysMessage,t)}async handleDhReplyMessage(e,t){var i,n,s,o,r,a;if(!this.isClientSession)return;if(!this.exchangeContext)throw new x.SshConnectionError("Key exchange was not started.",m.SshDisconnectReason.protocolError);const h=this.session.config,l=this.exchangeContext.exchange,g=this.exchangeContext.publicKey,u=h.getPublicKeyAlgorithm(g),d=h.getEncryptionAlgorithm(this.exchangeContext.clientEncryption),v=h.getEncryptionAlgorithm(this.exchangeContext.serverEncryption),C=h.getHmacAlgorithm(this.exchangeContext.serverHmac),p=h.getHmacAlgorithm(this.exchangeContext.clientHmac),w=this.exchangeContext.exchangeValue,E=e.f;if(!l||!w)throw new x.SshConnectionError("Failed to initialize crypto after key exchange.",m.SshDisconnectReason.keyExchangeFailed);this.hostKey=u.createKeyPair(),await this.hostKey.setPublicKeyBytes(e.hostKey);const K=await l.decryptKeyExchange(E),S=e.hostKey,A=await this.computeExchangeHash(l,S,w,E,K),k=u.readSignatureData(e.signature),I=u.createVerifier(this.hostKey);let b;try{b=await I.verify(A,k)}catch(e){if(!(e instanceof Error))throw e;throw this.trace(f.TraceLevel.Error,f.SshTraceEventIds.serverAuthenticationFailed,`Server public key verification error: ${e.message}`,e),new x.SshConnectionError(`Server public key verification failed: ${e.message}`,m.SshDisconnectReason.hostKeyNotVerifiable)}if(!b)throw this.trace(f.TraceLevel.Warning,f.SshTraceEventIds.serverAuthenticationFailed,"Server public key verification failed."),new x.SshConnectionError("Server public key verification failed.",m.SshDisconnectReason.hostKeyNotVerifiable);this.trace(f.TraceLevel.Verbose,f.SshTraceEventIds.sessionAuthenticated,"Server public key verification succeeded."),null==this.session.sessionId&&(this.session.sessionId=A);const[N,M,T,B,P,D]=await this.computeKeys(l,K,A,d,v,p,C),V=null!==(i=await(null==d?void 0:d.createCipher(!0,T,N)))&&void 0!==i?i:null,R=null!==(n=await(null==v?void 0:v.createCipher(!1,B,M)))&&void 0!==n?n:null,H=null!==(s=await(null==p?void 0:p.createSigner(P)))&&void 0!==s?s:null,L=null!==(o=await(null==C?void 0:C.createVerifier(D)))&&void 0!==o?o:null,F=new y.SshSessionAlgorithms;F.publicKeyAlgorithmName=g,F.cipher=V,F.decipher=R,F.signer=H,F.verifier=L,F.messageSigner=(null===(r=V)||void 0===r?void 0:r.authenticatedEncryption)?V:H,F.messageVerifier=(null===(a=R)||void 0===a?void 0:a.authenticatedEncryption)?R:L,F.compressor=h.getCompressionAlgorithm(this.exchangeContext.clientCompression),F.decompressor=h.getCompressionAlgorithm(this.exchangeContext.serverCompression),this.exchangeContext.newAlgorithms=F,N&&N.fill(0),T&&T.fill(0),P&&P.fill(0),M&&M.fill(0),B&&B.fill(0),D&&D.fill(0),await this.session.sendMessage(new c.NewKeysMessage,t)}chooseAlgorithm(e,t,i){var n;let s,o;this.isClientSession?(s=i||[],o=t):(s=t,o=i||[]);const r=`${e} negotiation: Server (${s.join(", ")}) Client (${o.join(", ")})`;if(this.session.remoteVersion.isVsSsh&&(null===(n=this.session.remoteVersion.version)||void 0===n?void 0:n.startsWith("2."))){const e=s;s=o,o=e}for(let e of o)for(let t of s)if(t===e){const e=t;return this.trace(f.TraceLevel.Info,f.SshTraceEventIds.algorithmNegotiation,`${r} => ${e}`),e}throw new Error(`Failed ${r}`)}async computeExchangeHash(e,t,i,n,s){if(!this.session.remoteVersion)throw new Error("Key exchange not completed.");const a=new g.SshDataWriter(o.Buffer.alloc(2048));this.isClientSession?(a.writeString(r.SshSession.localVersion.toString(),"ascii"),a.writeString(this.session.remoteVersion.toString(),"ascii")):(a.writeString(this.session.remoteVersion.toString(),"ascii"),a.writeString(r.SshSession.localVersion.toString(),"ascii")),a.writeBinary(this.exchangeContext.clientKexInitPayload),a.writeBinary(this.exchangeContext.serverKexInitPayload),a.writeBinary(t),a.writeBigInt(h.BigInt.fromBytes(i,{unsigned:!0})),a.writeBigInt(h.BigInt.fromBytes(n,{unsigned:!0})),a.writeBigInt(h.BigInt.fromBytes(s,{unsigned:!0}));return await e.sign(a.toBuffer())}async computeKeys(e,t,i,n,s,r,a){var h,c;const l=new g.SshDataWriter(o.Buffer.alloc(4+t.length+i.length+Math.max(1+(null!==(c=null===(h=this.session.sessionId)||void 0===h?void 0:h.length)&&void 0!==c?c:0),e.digestLength)));l.writeBinary(t),l.write(i);const x=l.position;return[n&&await this.computeKey(e,l,x,n.blockLength,"A"),s&&await this.computeKey(e,l,x,s.blockLength,"B"),n&&await this.computeKey(e,l,x,n.keyLength,"C"),s&&await this.computeKey(e,l,x,s.keyLength,"D"),r&&await this.computeKey(e,l,x,r.keyLength,"E"),a&&await this.computeKey(e,l,x,a.keyLength,"F")]}async computeKey(e,t,i,n,s){const r=o.Buffer.alloc(n);let a=0,h=0,c=null;if(!this.session.sessionId)throw new Error("Session ID not set.");for(;a<n;)t.position=i,c?t.write(c):(t.writeByte(s.charCodeAt(0)),t.write(this.session.sessionId)),c=await e.sign(t.toBuffer()),h=Math.min(c.length,n-a),c.copy(r,a),a+=h;return c&&c.fill(0),r}};w.serviceName="ssh-keyexchange",w=n=s([(0,d.serviceActivation)({serviceRequest:n.serviceName})],w),t.KeyExchangeService=w}}]);